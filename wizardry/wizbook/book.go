// this file has been generated by github.com/fasterthanlime/wizardry
// from a set of magic rules. you probably don't want to edit it by hand

package wizbook

import (
  "encoding/binary"
  "github.com/fasterthanlime/wizardry/wizardry"
)

// silence import errors, if we don't use string/search etc.
var _ wizardry.StringTestFlags
var le binary.ByteOrder = binary.LittleEndian
var be binary.ByteOrder = binary.BigEndian

func readUint8be(tb []byte, off int64) (uint8, bool) {
  if int64(len(tb)) < off+1 {
    return 0, false
  }
  pi := uint8(tb[off])
  return pi, true
}

func readUint8le(tb []byte, off int64) (uint8, bool) {
  if int64(len(tb)) < off+1 {
    return 0, false
  }
  pi := uint8(tb[off])
  return pi, true
}

func readUint16be(tb []byte, off int64) (uint16, bool) {
  if int64(len(tb)) < off+2 {
    return 0, false
  }
  pi := be.Uint16(tb[off:])
  return pi, true
}

func readUint16le(tb []byte, off int64) (uint16, bool) {
  if int64(len(tb)) < off+2 {
    return 0, false
  }
  pi := le.Uint16(tb[off:])
  return pi, true
}

func readUint32be(tb []byte, off int64) (uint32, bool) {
  if int64(len(tb)) < off+4 {
    return 0, false
  }
  pi := be.Uint32(tb[off:])
  return pi, true
}

func readUint32le(tb []byte, off int64) (uint32, bool) {
  if int64(len(tb)) < off+4 {
    return 0, false
  }
  pi := le.Uint32(tb[off:])
  return pi, true
}

func readUint64be(tb []byte, off int64) (uint64, bool) {
  if int64(len(tb)) < off+8 {
    return 0, false
  }
  pi := be.Uint64(tb[off:])
  return pi, true
}

func readUint64le(tb []byte, off int64) (uint64, bool) {
  if int64(len(tb)) < off+8 {
    return 0, false
  }
  pi := le.Uint64(tb[off:])
  return pi, true
}

func IdentifyElfLe(tb []byte, pageOff int64) ([]string, error) {
  var out []string
  var off int64
  m0 := false
  m1 := false
  m2 := false
  m3 := false

  if m0 {
    // >0x10    shortle    0    no file type,
    off = pageOff + 16
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      out = append(out, "no file type,")
    }

    // >0x10    shortle    1    relocatable,
    off = pageOff + 16
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x1)
    }
    if m1 {
      out = append(out, "relocatable,")
    }

    // >0x10    shortle    2    executable,
    off = pageOff + 16
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x2)
    }
    if m1 {
      out = append(out, "executable,")
    }

    // >0x10    shortle    3    shared object,
    off = pageOff + 16
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x3)
    }
    if m1 {
      out = append(out, "shared object,")
    }

    // >0x10    shortle    4    core file
    off = pageOff + 16
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x4)
    }
    if m1 {
      out = append(out, "core file")
    }

    // >0x12    clear    
    off = pageOff + 18
    // uh oh unhandled kind

    // >0x12    shortle    0    no machine,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      out = append(out, "no machine,")
    }

    // >0x12    shortle    1    AT&T WE32100,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x1)
    }
    if m1 {
      out = append(out, "AT&T WE32100,")
    }

    // >0x12    shortle    2    SPARC,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x2)
    }
    if m1 {
      out = append(out, "SPARC,")
    }

    // >0x12    shortle    3    Intel 80386,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x3)
    }
    if m1 {
      out = append(out, "Intel 80386,")
    }

    // >0x12    shortle    4    Motorola m68k,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x4)
    }
    if m1 {
      out = append(out, "Motorola m68k,")
    }

    if m1 {
      // >>0x4    bytele    1    
      off = pageOff + 4
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x1)
      }

      if m2 {
        // >>>0x24    longle    0    68020,
        off = pageOff + 36
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x0)
        }
        if m3 {
          out = append(out, "68020,")
        }

      }
    }
    // >0x12    shortle    5    Motorola m88k,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x5)
    }
    if m1 {
      out = append(out, "Motorola m88k,")
    }

    // >0x12    shortle    6    Intel 80486,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x6)
    }
    if m1 {
      out = append(out, "Intel 80486,")
    }

    // >0x12    shortle    7    Intel 80860,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x7)
    }
    if m1 {
      out = append(out, "Intel 80860,")
    }

    // >0x12    shortle    8    MIPS,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x8)
    }
    if m1 {
      out = append(out, "MIPS,")
    }

    if m1 {
      // >>0x4    bytele    1    
      off = pageOff + 4
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x1)
      }

    }
    // >0x12    shortle    a    MIPS,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xa)
    }
    if m1 {
      out = append(out, "MIPS,")
    }

    if m1 {
      // >>0x4    bytele    1    
      off = pageOff + 4
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x1)
      }

    }
    // >0x12    shortle    8    
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x8)
    }

    if m1 {
      // >>0x4    bytele    1    
      off = pageOff + 4
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x1)
      }

      if m2 {
        // >>>0x24    longle    0&0xf0000000    MIPS-I
        off = pageOff + 36
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x0)
        }
        if m3 {
          out = append(out, "MIPS-I")
        }

        // >>>0x24    longle    10000000&0xf0000000    MIPS-II
        off = pageOff + 36
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x10000000)
        }
        if m3 {
          out = append(out, "MIPS-II")
        }

        // >>>0x24    longle    20000000&0xf0000000    MIPS-III
        off = pageOff + 36
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x20000000)
        }
        if m3 {
          out = append(out, "MIPS-III")
        }

        // >>>0x24    longle    30000000&0xf0000000    MIPS-IV
        off = pageOff + 36
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x30000000)
        }
        if m3 {
          out = append(out, "MIPS-IV")
        }

        // >>>0x24    longle    40000000&0xf0000000    MIPS-V
        off = pageOff + 36
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x40000000)
        }
        if m3 {
          out = append(out, "MIPS-V")
        }

        // >>>0x24    longle    50000000&0xf0000000    MIPS32
        off = pageOff + 36
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x50000000)
        }
        if m3 {
          out = append(out, "MIPS32")
        }

        // >>>0x24    longle    60000000&0xf0000000    MIPS64
        off = pageOff + 36
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x60000000)
        }
        if m3 {
          out = append(out, "MIPS64")
        }

        // >>>0x24    longle    70000000&0xf0000000    MIPS32 rel2
        off = pageOff + 36
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x70000000)
        }
        if m3 {
          out = append(out, "MIPS32 rel2")
        }

        // >>>0x24    longle    80000000&0xf0000000    MIPS64 rel2
        off = pageOff + 36
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x80000000)
        }
        if m3 {
          out = append(out, "MIPS64 rel2")
        }

      }
      // >>0x4    bytele    2    
      off = pageOff + 4
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x2)
      }

      if m2 {
        // >>>0x30    longle    0&0xf0000000    MIPS-I
        off = pageOff + 48
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x0)
        }
        if m3 {
          out = append(out, "MIPS-I")
        }

        // >>>0x30    longle    10000000&0xf0000000    MIPS-II
        off = pageOff + 48
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x10000000)
        }
        if m3 {
          out = append(out, "MIPS-II")
        }

        // >>>0x30    longle    20000000&0xf0000000    MIPS-III
        off = pageOff + 48
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x20000000)
        }
        if m3 {
          out = append(out, "MIPS-III")
        }

        // >>>0x30    longle    30000000&0xf0000000    MIPS-IV
        off = pageOff + 48
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x30000000)
        }
        if m3 {
          out = append(out, "MIPS-IV")
        }

        // >>>0x30    longle    40000000&0xf0000000    MIPS-V
        off = pageOff + 48
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x40000000)
        }
        if m3 {
          out = append(out, "MIPS-V")
        }

        // >>>0x30    longle    50000000&0xf0000000    MIPS32
        off = pageOff + 48
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x50000000)
        }
        if m3 {
          out = append(out, "MIPS32")
        }

        // >>>0x30    longle    60000000&0xf0000000    MIPS64
        off = pageOff + 48
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x60000000)
        }
        if m3 {
          out = append(out, "MIPS64")
        }

        // >>>0x30    longle    70000000&0xf0000000    MIPS32 rel2
        off = pageOff + 48
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x70000000)
        }
        if m3 {
          out = append(out, "MIPS32 rel2")
        }

        // >>>0x30    longle    80000000&0xf0000000    MIPS64 rel2
        off = pageOff + 48
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x80000000)
        }
        if m3 {
          out = append(out, "MIPS64 rel2")
        }

      }
    }
    // >0x12    shortle    9    Amdahl,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x9)
    }
    if m1 {
      out = append(out, "Amdahl,")
    }

    // >0x12    shortle    a    MIPS (deprecated),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xa)
    }
    if m1 {
      out = append(out, "MIPS (deprecated),")
    }

    // >0x12    shortle    b    RS6000,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xb)
    }
    if m1 {
      out = append(out, "RS6000,")
    }

    // >0x12    shortle    f    PA-RISC,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xf)
    }
    if m1 {
      out = append(out, "PA-RISC,")
    }

    if m1 {
      // >>0x4    bytele    1    
      off = pageOff + 4
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x1)
      }

      if m2 {
        // >>>0x26    shortle    214    2.0
        off = pageOff + 38
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x214)
        }
        if m3 {
          out = append(out, "2.0")
        }

      }
      // >>0x4    bytele    2    
      off = pageOff + 4
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x2)
      }

      if m2 {
        // >>>0x32    shortle    214    2.0
        off = pageOff + 50
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x214)
        }
        if m3 {
          out = append(out, "2.0")
        }

      }
    }
    // >0x12    shortle    10    nCUBE,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x10)
    }
    if m1 {
      out = append(out, "nCUBE,")
    }

    // >0x12    shortle    11    Fujitsu VPP500,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x11)
    }
    if m1 {
      out = append(out, "Fujitsu VPP500,")
    }

    // >0x12    shortle    12    SPARC32PLUS,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x12)
    }
    if m1 {
      out = append(out, "SPARC32PLUS,")
    }

    if m1 {
      // >>0x4    bytele    1    
      off = pageOff + 4
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x1)
      }

      if m2 {
        // >>>0x24    longle    100&0xffff00    V8+ Required,
        off = pageOff + 36
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x100)
        }
        if m3 {
          out = append(out, "V8+ Required,")
        }

        // >>>0x24    longle    200&0xffff00    Sun UltraSPARC1 Extensions Required,
        off = pageOff + 36
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x200)
        }
        if m3 {
          out = append(out, "Sun UltraSPARC1 Extensions Required,")
        }

        // >>>0x24    longle    400&0xffff00    HaL R1 Extensions Required,
        off = pageOff + 36
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x400)
        }
        if m3 {
          out = append(out, "HaL R1 Extensions Required,")
        }

        // >>>0x24    longle    800&0xffff00    Sun UltraSPARC3 Extensions Required,
        off = pageOff + 36
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x800)
        }
        if m3 {
          out = append(out, "Sun UltraSPARC3 Extensions Required,")
        }

      }
    }
    // >0x12    shortle    13    Intel 80960,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x13)
    }
    if m1 {
      out = append(out, "Intel 80960,")
    }

    // >0x12    shortle    14    PowerPC or cisco 4500,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x14)
    }
    if m1 {
      out = append(out, "PowerPC or cisco 4500,")
    }

    // >0x12    shortle    15    64-bit PowerPC or cisco 7500,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x15)
    }
    if m1 {
      out = append(out, "64-bit PowerPC or cisco 7500,")
    }

    // >0x12    shortle    16    IBM S/390,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x16)
    }
    if m1 {
      out = append(out, "IBM S/390,")
    }

    // >0x12    shortle    17    Cell SPU,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x17)
    }
    if m1 {
      out = append(out, "Cell SPU,")
    }

    // >0x12    shortle    18    cisco SVIP,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x18)
    }
    if m1 {
      out = append(out, "cisco SVIP,")
    }

    // >0x12    shortle    19    cisco 7200,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x19)
    }
    if m1 {
      out = append(out, "cisco 7200,")
    }

    // >0x12    shortle    24    NEC V800 or cisco 12000,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x24)
    }
    if m1 {
      out = append(out, "NEC V800 or cisco 12000,")
    }

    // >0x12    shortle    25    Fujitsu FR20,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x25)
    }
    if m1 {
      out = append(out, "Fujitsu FR20,")
    }

    // >0x12    shortle    26    TRW RH-32,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x26)
    }
    if m1 {
      out = append(out, "TRW RH-32,")
    }

    // >0x12    shortle    27    Motorola RCE,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x27)
    }
    if m1 {
      out = append(out, "Motorola RCE,")
    }

    // >0x12    shortle    28    ARM,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x28)
    }
    if m1 {
      out = append(out, "ARM,")
    }

    if m1 {
      // >>0x4    bytele    1    
      off = pageOff + 4
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x1)
      }

      if m2 {
        // >>>0x24    longle    4000000&0xff000000    EABI4
        off = pageOff + 36
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x4000000)
        }
        if m3 {
          out = append(out, "EABI4")
        }

        // >>>0x24    longle    5000000&0xff000000    EABI5
        off = pageOff + 36
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x5000000)
        }
        if m3 {
          out = append(out, "EABI5")
        }

      }
    }
    // >0x12    shortle    29    Alpha,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x29)
    }
    if m1 {
      out = append(out, "Alpha,")
    }

    // >0x12    shortle    2a    Renesas SH,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x2a)
    }
    if m1 {
      out = append(out, "Renesas SH,")
    }

    // >0x12    shortle    2b    SPARC V9,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x2b)
    }
    if m1 {
      out = append(out, "SPARC V9,")
    }

    if m1 {
      // >>0x4    bytele    2    
      off = pageOff + 4
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x2)
      }

      if m2 {
        // >>>0x30    longle    200&0xffff00    Sun UltraSPARC1 Extensions Required,
        off = pageOff + 48
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x200)
        }
        if m3 {
          out = append(out, "Sun UltraSPARC1 Extensions Required,")
        }

        // >>>0x30    longle    400&0xffff00    HaL R1 Extensions Required,
        off = pageOff + 48
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x400)
        }
        if m3 {
          out = append(out, "HaL R1 Extensions Required,")
        }

        // >>>0x30    longle    800&0xffff00    Sun UltraSPARC3 Extensions Required,
        off = pageOff + 48
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x800)
        }
        if m3 {
          out = append(out, "Sun UltraSPARC3 Extensions Required,")
        }

        // >>>0x30    longle    0&0x3    total store ordering,
        off = pageOff + 48
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x0)
        }
        if m3 {
          out = append(out, "total store ordering,")
        }

        // >>>0x30    longle    1&0x3    partial store ordering,
        off = pageOff + 48
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x1)
        }
        if m3 {
          out = append(out, "partial store ordering,")
        }

        // >>>0x30    longle    2&0x3    relaxed memory ordering,
        off = pageOff + 48
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x2)
        }
        if m3 {
          out = append(out, "relaxed memory ordering,")
        }

      }
    }
    // >0x12    shortle    2c    Siemens Tricore Embedded Processor,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x2c)
    }
    if m1 {
      out = append(out, "Siemens Tricore Embedded Processor,")
    }

    // >0x12    shortle    2d    Argonaut RISC Core, Argonaut Technologies Inc.,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x2d)
    }
    if m1 {
      out = append(out, "Argonaut RISC Core, Argonaut Technologies Inc.,")
    }

    // >0x12    shortle    2e    Renesas H8/300,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x2e)
    }
    if m1 {
      out = append(out, "Renesas H8/300,")
    }

    // >0x12    shortle    2f    Renesas H8/300H,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x2f)
    }
    if m1 {
      out = append(out, "Renesas H8/300H,")
    }

    // >0x12    shortle    30    Renesas H8S,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x30)
    }
    if m1 {
      out = append(out, "Renesas H8S,")
    }

    // >0x12    shortle    31    Renesas H8/500,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x31)
    }
    if m1 {
      out = append(out, "Renesas H8/500,")
    }

    // >0x12    shortle    32    IA-64,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x32)
    }
    if m1 {
      out = append(out, "IA-64,")
    }

    // >0x12    shortle    33    Stanford MIPS-X,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x33)
    }
    if m1 {
      out = append(out, "Stanford MIPS-X,")
    }

    // >0x12    shortle    34    Motorola Coldfire,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x34)
    }
    if m1 {
      out = append(out, "Motorola Coldfire,")
    }

    // >0x12    shortle    35    Motorola M68HC12,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x35)
    }
    if m1 {
      out = append(out, "Motorola M68HC12,")
    }

    // >0x12    shortle    36    Fujitsu MMA,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x36)
    }
    if m1 {
      out = append(out, "Fujitsu MMA,")
    }

    // >0x12    shortle    37    Siemens PCP,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x37)
    }
    if m1 {
      out = append(out, "Siemens PCP,")
    }

    // >0x12    shortle    38    Sony nCPU,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x38)
    }
    if m1 {
      out = append(out, "Sony nCPU,")
    }

    // >0x12    shortle    39    Denso NDR1,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x39)
    }
    if m1 {
      out = append(out, "Denso NDR1,")
    }

    // >0x12    shortle    3a    Start*Core,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x3a)
    }
    if m1 {
      out = append(out, "Start*Core,")
    }

    // >0x12    shortle    3b    Toyota ME16,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x3b)
    }
    if m1 {
      out = append(out, "Toyota ME16,")
    }

    // >0x12    shortle    3c    ST100,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x3c)
    }
    if m1 {
      out = append(out, "ST100,")
    }

    // >0x12    shortle    3d    Tinyj emb.,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x3d)
    }
    if m1 {
      out = append(out, "Tinyj emb.,")
    }

    // >0x12    shortle    3e    x86-64,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x3e)
    }
    if m1 {
      out = append(out, "x86-64,")
    }

    // >0x12    shortle    3f    Sony DSP,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x3f)
    }
    if m1 {
      out = append(out, "Sony DSP,")
    }

    // >0x12    shortle    40    DEC PDP-10,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x40)
    }
    if m1 {
      out = append(out, "DEC PDP-10,")
    }

    // >0x12    shortle    41    DEC PDP-11,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x41)
    }
    if m1 {
      out = append(out, "DEC PDP-11,")
    }

    // >0x12    shortle    42    FX66,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x42)
    }
    if m1 {
      out = append(out, "FX66,")
    }

    // >0x12    shortle    43    ST9+ 8/16 bit,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x43)
    }
    if m1 {
      out = append(out, "ST9+ 8/16 bit,")
    }

    // >0x12    shortle    44    ST7 8 bit,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x44)
    }
    if m1 {
      out = append(out, "ST7 8 bit,")
    }

    // >0x12    shortle    45    MC68HC16,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x45)
    }
    if m1 {
      out = append(out, "MC68HC16,")
    }

    // >0x12    shortle    46    MC68HC11,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x46)
    }
    if m1 {
      out = append(out, "MC68HC11,")
    }

    // >0x12    shortle    47    MC68HC08,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x47)
    }
    if m1 {
      out = append(out, "MC68HC08,")
    }

    // >0x12    shortle    48    MC68HC05,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x48)
    }
    if m1 {
      out = append(out, "MC68HC05,")
    }

    // >0x12    shortle    49    SGI SVx or Cray NV1,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x49)
    }
    if m1 {
      out = append(out, "SGI SVx or Cray NV1,")
    }

    // >0x12    shortle    4a    ST19 8 bit,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x4a)
    }
    if m1 {
      out = append(out, "ST19 8 bit,")
    }

    // >0x12    shortle    4b    Digital VAX,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x4b)
    }
    if m1 {
      out = append(out, "Digital VAX,")
    }

    // >0x12    shortle    4c    Axis cris,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x4c)
    }
    if m1 {
      out = append(out, "Axis cris,")
    }

    // >0x12    shortle    4d    Infineon 32-bit embedded,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x4d)
    }
    if m1 {
      out = append(out, "Infineon 32-bit embedded,")
    }

    // >0x12    shortle    4e    Element 14 64-bit DSP,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x4e)
    }
    if m1 {
      out = append(out, "Element 14 64-bit DSP,")
    }

    // >0x12    shortle    4f    LSI Logic 16-bit DSP,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x4f)
    }
    if m1 {
      out = append(out, "LSI Logic 16-bit DSP,")
    }

    // >0x12    shortle    50    MMIX,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x50)
    }
    if m1 {
      out = append(out, "MMIX,")
    }

    // >0x12    shortle    51    Harvard machine-independent,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x51)
    }
    if m1 {
      out = append(out, "Harvard machine-independent,")
    }

    // >0x12    shortle    52    SiTera Prism,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x52)
    }
    if m1 {
      out = append(out, "SiTera Prism,")
    }

    // >0x12    shortle    53    Atmel AVR 8-bit,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x53)
    }
    if m1 {
      out = append(out, "Atmel AVR 8-bit,")
    }

    // >0x12    shortle    54    Fujitsu FR30,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x54)
    }
    if m1 {
      out = append(out, "Fujitsu FR30,")
    }

    // >0x12    shortle    55    Mitsubishi D10V,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x55)
    }
    if m1 {
      out = append(out, "Mitsubishi D10V,")
    }

    // >0x12    shortle    56    Mitsubishi D30V,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x56)
    }
    if m1 {
      out = append(out, "Mitsubishi D30V,")
    }

    // >0x12    shortle    57    NEC v850,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x57)
    }
    if m1 {
      out = append(out, "NEC v850,")
    }

    // >0x12    shortle    58    Renesas M32R,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x58)
    }
    if m1 {
      out = append(out, "Renesas M32R,")
    }

    // >0x12    shortle    59    Matsushita MN10300,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x59)
    }
    if m1 {
      out = append(out, "Matsushita MN10300,")
    }

    // >0x12    shortle    5a    Matsushita MN10200,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x5a)
    }
    if m1 {
      out = append(out, "Matsushita MN10200,")
    }

    // >0x12    shortle    5b    picoJava,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x5b)
    }
    if m1 {
      out = append(out, "picoJava,")
    }

    // >0x12    shortle    5c    OpenRISC,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x5c)
    }
    if m1 {
      out = append(out, "OpenRISC,")
    }

    // >0x12    shortle    5d    ARC Cores Tangent-A5,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x5d)
    }
    if m1 {
      out = append(out, "ARC Cores Tangent-A5,")
    }

    // >0x12    shortle    5e    Tensilica Xtensa,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x5e)
    }
    if m1 {
      out = append(out, "Tensilica Xtensa,")
    }

    // >0x12    shortle    5f    Alphamosaic VideoCore,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x5f)
    }
    if m1 {
      out = append(out, "Alphamosaic VideoCore,")
    }

    // >0x12    shortle    60    Thompson Multimedia,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x60)
    }
    if m1 {
      out = append(out, "Thompson Multimedia,")
    }

    // >0x12    shortle    61    NatSemi 32k,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x61)
    }
    if m1 {
      out = append(out, "NatSemi 32k,")
    }

    // >0x12    shortle    62    Tenor Network TPC,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x62)
    }
    if m1 {
      out = append(out, "Tenor Network TPC,")
    }

    // >0x12    shortle    63    Trebia SNP 1000,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x63)
    }
    if m1 {
      out = append(out, "Trebia SNP 1000,")
    }

    // >0x12    shortle    64    STMicroelectronics ST200,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x64)
    }
    if m1 {
      out = append(out, "STMicroelectronics ST200,")
    }

    // >0x12    shortle    65    Ubicom IP2022,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x65)
    }
    if m1 {
      out = append(out, "Ubicom IP2022,")
    }

    // >0x12    shortle    66    MAX Processor,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x66)
    }
    if m1 {
      out = append(out, "MAX Processor,")
    }

    // >0x12    shortle    67    NatSemi CompactRISC,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x67)
    }
    if m1 {
      out = append(out, "NatSemi CompactRISC,")
    }

    // >0x12    shortle    68    Fujitsu F2MC16,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x68)
    }
    if m1 {
      out = append(out, "Fujitsu F2MC16,")
    }

    // >0x12    shortle    69    TI msp430,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x69)
    }
    if m1 {
      out = append(out, "TI msp430,")
    }

    // >0x12    shortle    6a    Analog Devices Blackfin,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x6a)
    }
    if m1 {
      out = append(out, "Analog Devices Blackfin,")
    }

    // >0x12    shortle    6b    S1C33 Family of Seiko Epson,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x6b)
    }
    if m1 {
      out = append(out, "S1C33 Family of Seiko Epson,")
    }

    // >0x12    shortle    6c    Sharp embedded,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x6c)
    }
    if m1 {
      out = append(out, "Sharp embedded,")
    }

    // >0x12    shortle    6d    Arca RISC,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x6d)
    }
    if m1 {
      out = append(out, "Arca RISC,")
    }

    // >0x12    shortle    6e    PKU-Unity Ltd.,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x6e)
    }
    if m1 {
      out = append(out, "PKU-Unity Ltd.,")
    }

    // >0x12    shortle    6f    eXcess: 16/32/64-bit,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x6f)
    }
    if m1 {
      out = append(out, "eXcess: 16/32/64-bit,")
    }

    // >0x12    shortle    70    Icera Deep Execution Processor,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x70)
    }
    if m1 {
      out = append(out, "Icera Deep Execution Processor,")
    }

    // >0x12    shortle    71    Altera Nios II,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x71)
    }
    if m1 {
      out = append(out, "Altera Nios II,")
    }

    // >0x12    shortle    72    NatSemi CRX,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x72)
    }
    if m1 {
      out = append(out, "NatSemi CRX,")
    }

    // >0x12    shortle    73    Motorola XGATE,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x73)
    }
    if m1 {
      out = append(out, "Motorola XGATE,")
    }

    // >0x12    shortle    74    Infineon C16x/XC16x,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x74)
    }
    if m1 {
      out = append(out, "Infineon C16x/XC16x,")
    }

    // >0x12    shortle    75    Renesas M16C series,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x75)
    }
    if m1 {
      out = append(out, "Renesas M16C series,")
    }

    // >0x12    shortle    76    Microchip dsPIC30F,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x76)
    }
    if m1 {
      out = append(out, "Microchip dsPIC30F,")
    }

    // >0x12    shortle    77    Freescale RISC core,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x77)
    }
    if m1 {
      out = append(out, "Freescale RISC core,")
    }

    // >0x12    shortle    78    Renesas M32C series,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x78)
    }
    if m1 {
      out = append(out, "Renesas M32C series,")
    }

    // >0x12    shortle    83    Altium TSK3000 core,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x83)
    }
    if m1 {
      out = append(out, "Altium TSK3000 core,")
    }

    // >0x12    shortle    84    Freescale RS08,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x84)
    }
    if m1 {
      out = append(out, "Freescale RS08,")
    }

    // >0x12    shortle    86    Cyan Technology eCOG2,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x86)
    }
    if m1 {
      out = append(out, "Cyan Technology eCOG2,")
    }

    // >0x12    shortle    87    Sunplus S+core7 RISC,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x87)
    }
    if m1 {
      out = append(out, "Sunplus S+core7 RISC,")
    }

    // >0x12    shortle    88    New Japan Radio (NJR) 24-bit DSP,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x88)
    }
    if m1 {
      out = append(out, "New Japan Radio (NJR) 24-bit DSP,")
    }

    // >0x12    shortle    89    Broadcom VideoCore III,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x89)
    }
    if m1 {
      out = append(out, "Broadcom VideoCore III,")
    }

    // >0x12    shortle    8a    LatticeMico32,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x8a)
    }
    if m1 {
      out = append(out, "LatticeMico32,")
    }

    // >0x12    shortle    8b    Seiko Epson C17 family,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x8b)
    }
    if m1 {
      out = append(out, "Seiko Epson C17 family,")
    }

    // >0x12    shortle    8c    TI TMS320C6000 DSP family,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x8c)
    }
    if m1 {
      out = append(out, "TI TMS320C6000 DSP family,")
    }

    // >0x12    shortle    8d    TI TMS320C2000 DSP family,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x8d)
    }
    if m1 {
      out = append(out, "TI TMS320C2000 DSP family,")
    }

    // >0x12    shortle    8e    TI TMS320C55x DSP family,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x8e)
    }
    if m1 {
      out = append(out, "TI TMS320C55x DSP family,")
    }

    // >0x12    shortle    a0    STMicroelectronics 64bit VLIW DSP,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xa0)
    }
    if m1 {
      out = append(out, "STMicroelectronics 64bit VLIW DSP,")
    }

    // >0x12    shortle    a1    Cypress M8C,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xa1)
    }
    if m1 {
      out = append(out, "Cypress M8C,")
    }

    // >0x12    shortle    a2    Renesas R32C series,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xa2)
    }
    if m1 {
      out = append(out, "Renesas R32C series,")
    }

    // >0x12    shortle    a3    NXP TriMedia family,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xa3)
    }
    if m1 {
      out = append(out, "NXP TriMedia family,")
    }

    // >0x12    shortle    a4    QUALCOMM DSP6,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xa4)
    }
    if m1 {
      out = append(out, "QUALCOMM DSP6,")
    }

    // >0x12    shortle    a5    Intel 8051 and variants,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xa5)
    }
    if m1 {
      out = append(out, "Intel 8051 and variants,")
    }

    // >0x12    shortle    a6    STMicroelectronics STxP7x family,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xa6)
    }
    if m1 {
      out = append(out, "STMicroelectronics STxP7x family,")
    }

    // >0x12    shortle    a7    Andes embedded RISC,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xa7)
    }
    if m1 {
      out = append(out, "Andes embedded RISC,")
    }

    // >0x12    shortle    a8    Cyan eCOG1X family,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xa8)
    }
    if m1 {
      out = append(out, "Cyan eCOG1X family,")
    }

    // >0x12    shortle    a9    Dallas MAXQ30,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xa9)
    }
    if m1 {
      out = append(out, "Dallas MAXQ30,")
    }

    // >0x12    shortle    aa    New Japan Radio (NJR) 16-bit DSP,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xaa)
    }
    if m1 {
      out = append(out, "New Japan Radio (NJR) 16-bit DSP,")
    }

    // >0x12    shortle    ab    M2000 Reconfigurable RISC,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xab)
    }
    if m1 {
      out = append(out, "M2000 Reconfigurable RISC,")
    }

    // >0x12    shortle    ac    Cray NV2 vector architecture,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xac)
    }
    if m1 {
      out = append(out, "Cray NV2 vector architecture,")
    }

    // >0x12    shortle    ad    Renesas RX family,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xad)
    }
    if m1 {
      out = append(out, "Renesas RX family,")
    }

    // >0x12    shortle    ae    META,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xae)
    }
    if m1 {
      out = append(out, "META,")
    }

    // >0x12    shortle    af    MCST Elbrus,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xaf)
    }
    if m1 {
      out = append(out, "MCST Elbrus,")
    }

    // >0x12    shortle    b0    Cyan Technology eCOG16 family,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xb0)
    }
    if m1 {
      out = append(out, "Cyan Technology eCOG16 family,")
    }

    // >0x12    shortle    b1    NatSemi CompactRISC,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xb1)
    }
    if m1 {
      out = append(out, "NatSemi CompactRISC,")
    }

    // >0x12    shortle    b2    Freescale Extended Time Processing Unit,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xb2)
    }
    if m1 {
      out = append(out, "Freescale Extended Time Processing Unit,")
    }

    // >0x12    shortle    b3    Infineon SLE9X,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xb3)
    }
    if m1 {
      out = append(out, "Infineon SLE9X,")
    }

    // >0x12    shortle    b4    Intel L1OM,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xb4)
    }
    if m1 {
      out = append(out, "Intel L1OM,")
    }

    // >0x12    shortle    b5    Intel K1OM,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xb5)
    }
    if m1 {
      out = append(out, "Intel K1OM,")
    }

    // >0x12    shortle    b7    ARM aarch64,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xb7)
    }
    if m1 {
      out = append(out, "ARM aarch64,")
    }

    // >0x12    shortle    b9    Atmel 32-bit family,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xb9)
    }
    if m1 {
      out = append(out, "Atmel 32-bit family,")
    }

    // >0x12    shortle    ba    STMicroeletronics STM8 8-bit,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xba)
    }
    if m1 {
      out = append(out, "STMicroeletronics STM8 8-bit,")
    }

    // >0x12    shortle    bb    Tilera TILE64,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xbb)
    }
    if m1 {
      out = append(out, "Tilera TILE64,")
    }

    // >0x12    shortle    bc    Tilera TILEPro,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xbc)
    }
    if m1 {
      out = append(out, "Tilera TILEPro,")
    }

    // >0x12    shortle    bd    Xilinx MicroBlaze 32-bit RISC,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xbd)
    }
    if m1 {
      out = append(out, "Xilinx MicroBlaze 32-bit RISC,")
    }

    // >0x12    shortle    be    NVIDIA CUDA architecture,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xbe)
    }
    if m1 {
      out = append(out, "NVIDIA CUDA architecture,")
    }

    // >0x12    shortle    bf    Tilera TILE-Gx,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xbf)
    }
    if m1 {
      out = append(out, "Tilera TILE-Gx,")
    }

    // >0x12    shortle    c5    Renesas RL78 family,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xc5)
    }
    if m1 {
      out = append(out, "Renesas RL78 family,")
    }

    // >0x12    shortle    c7    Renesas 78K0R,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xc7)
    }
    if m1 {
      out = append(out, "Renesas 78K0R,")
    }

    // >0x12    shortle    1057    AVR (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x1057)
    }
    if m1 {
      out = append(out, "AVR (unofficial),")
    }

    // >0x12    shortle    1059    MSP430 (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x1059)
    }
    if m1 {
      out = append(out, "MSP430 (unofficial),")
    }

    // >0x12    shortle    1223    Adapteva Epiphany (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x1223)
    }
    if m1 {
      out = append(out, "Adapteva Epiphany (unofficial),")
    }

    // >0x12    shortle    2530    Morpho MT (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x2530)
    }
    if m1 {
      out = append(out, "Morpho MT (unofficial),")
    }

    // >0x12    shortle    3330    FR30 (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x3330)
    }
    if m1 {
      out = append(out, "FR30 (unofficial),")
    }

    // >0x12    shortle    3426    OpenRISC (obsolete),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x3426)
    }
    if m1 {
      out = append(out, "OpenRISC (obsolete),")
    }

    // >0x12    shortle    4688    Infineon C166 (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x4688)
    }
    if m1 {
      out = append(out, "Infineon C166 (unofficial),")
    }

    // >0x12    shortle    5441    Cygnus FRV (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x5441)
    }
    if m1 {
      out = append(out, "Cygnus FRV (unofficial),")
    }

    // >0x12    shortle    5aa5    DLX (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x5aa5)
    }
    if m1 {
      out = append(out, "DLX (unofficial),")
    }

    // >0x12    shortle    7650    Cygnus D10V (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x7650)
    }
    if m1 {
      out = append(out, "Cygnus D10V (unofficial),")
    }

    // >0x12    shortle    7676    Cygnus D30V (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x7676)
    }
    if m1 {
      out = append(out, "Cygnus D30V (unofficial),")
    }

    // >0x12    shortle    8217    Ubicom IP2xxx (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x8217)
    }
    if m1 {
      out = append(out, "Ubicom IP2xxx (unofficial),")
    }

    // >0x12    shortle    8472    OpenRISC (obsolete),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x8472)
    }
    if m1 {
      out = append(out, "OpenRISC (obsolete),")
    }

    // >0x12    shortle    9025    Cygnus PowerPC (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x9025)
    }
    if m1 {
      out = append(out, "Cygnus PowerPC (unofficial),")
    }

    // >0x12    shortle    9026    Alpha (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x9026)
    }
    if m1 {
      out = append(out, "Alpha (unofficial),")
    }

    // >0x12    shortle    9041    Cygnus M32R (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x9041)
    }
    if m1 {
      out = append(out, "Cygnus M32R (unofficial),")
    }

    // >0x12    shortle    9080    Cygnus V850 (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x9080)
    }
    if m1 {
      out = append(out, "Cygnus V850 (unofficial),")
    }

    // >0x12    shortle    a390    IBM S/390 (obsolete),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xa390)
    }
    if m1 {
      out = append(out, "IBM S/390 (obsolete),")
    }

    // >0x12    shortle    abc7    Old Xtensa (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xabc7)
    }
    if m1 {
      out = append(out, "Old Xtensa (unofficial),")
    }

    // >0x12    shortle    ad45    xstormy16 (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xad45)
    }
    if m1 {
      out = append(out, "xstormy16 (unofficial),")
    }

    // >0x12    shortle    baab    Old MicroBlaze (unofficial),,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xbaab)
    }
    if m1 {
      out = append(out, "Old MicroBlaze (unofficial),,")
    }

    // >0x12    shortle    beef    Cygnus MN10300 (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xbeef)
    }
    if m1 {
      out = append(out, "Cygnus MN10300 (unofficial),")
    }

    // >0x12    shortle    dead    Cygnus MN10200 (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xdead)
    }
    if m1 {
      out = append(out, "Cygnus MN10200 (unofficial),")
    }

    // >0x12    shortle    f00d    Toshiba MeP (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xf00d)
    }
    if m1 {
      out = append(out, "Toshiba MeP (unofficial),")
    }

    // >0x12    shortle    feb0    Renesas M32C (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xfeb0)
    }
    if m1 {
      out = append(out, "Renesas M32C (unofficial),")
    }

    // >0x12    shortle    feba    Vitesse IQ2000 (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xfeba)
    }
    if m1 {
      out = append(out, "Vitesse IQ2000 (unofficial),")
    }

    // >0x12    shortle    febb    NIOS (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xfebb)
    }
    if m1 {
      out = append(out, "NIOS (unofficial),")
    }

    // >0x12    shortle    feed    Moxie (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xfeed)
    }
    if m1 {
      out = append(out, "Moxie (unofficial),")
    }

    // >0x12    default    
    off = pageOff + 18
    // uh oh unhandled kind

    if m1 {
      // >>0x12    shortle    0    *unknown arch 0x%x*
      off = pageOff + 18
      {
        iv, ok := readUint16be(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }
      if m2 {
        out = append(out, "*unknown arch 0x%x*")
      }

    }
    // >0x14    longle    0    invalid version
    off = pageOff + 20
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      out = append(out, "invalid version")
    }

    // >0x14    longle    1    version 1
    off = pageOff + 20
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) == 0x1)
    }
    if m1 {
      out = append(out, "version 1")
    }

  }
  return out, nil
}

func IdentifyIcoEntry(tb []byte, pageOff int64) ([]string, error) {
  var out []string
  var off int64
  m0 := false
  m1 := false

  if m0 {
    // >0x0    use   cur-ico-entry    
    off = pageOff + 0
    // uh oh unhandled kind

    // >0x4    ushortle    1    \b, %d planes
    off = pageOff + 4
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (int64(int16(iv)) > 0x1)
    }
    if m1 {
      out = append(out, "\\b, %d planes")
    }

    // >0x6    ushortle    1    \b, %d bits/pixel
    off = pageOff + 6
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (int64(int16(iv)) > 0x1)
    }
    if m1 {
      out = append(out, "\\b, %d bits/pixel")
    }

  }
  return out, nil
}

func IdentifyCurIcoEntry(tb []byte, pageOff int64) ([]string, error) {
  var out []string
  var off int64
  m0 := false
  m1 := false

  if m0 {
    // >0x0    bytele    0    \b, 256x
    off = pageOff + 0
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      out = append(out, "\\b, 256x")
    }

    // >0x0    bytele    0    \b, %dx
    off = pageOff + 0
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) != 0x0)
    }
    if m1 {
      out = append(out, "\\b, %dx")
    }

    // >0x1    bytele    0    \b256
    off = pageOff + 1
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      out = append(out, "\\b256")
    }

    // >0x1    bytele    0    \b%d
    off = pageOff + 1
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) != 0x0)
    }
    if m1 {
      out = append(out, "\\b%d")
    }

    // >0x2    ubytele    0    \b, %d colors
    off = pageOff + 2
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) != 0x0)
    }
    if m1 {
      out = append(out, "\\b, %d colors")
    }

    // >(0xc.longle)    ulongbe    89504e47    
    // uh oh indirect offset
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) == 0x89504e47)
    }

    // >(0xc.longle)    ulongbe    89504e47    
    // uh oh indirect offset
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) != 0x89504e47)
    }

  }
  return out, nil
}

func Identify(tb []byte, pageOff int64) ([]string, error) {
  var out []string
  var off int64
  m0 := false
  m1 := false
  m2 := false
  m3 := false
  m4 := false
  m5 := false
  m6 := false

  // 0x0    string    "\u007fELF"    ELF
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "ELF")
  }

  if m0 {
    // >0x4    bytele    0    invalid class
    off = pageOff + 4
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      out = append(out, "invalid class")
    }

    // >0x4    bytele    1    32-bit
    off = pageOff + 4
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) == 0x1)
    }
    if m1 {
      out = append(out, "32-bit")
    }

    // >0x4    bytele    2    64-bit
    off = pageOff + 4
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) == 0x2)
    }
    if m1 {
      out = append(out, "64-bit")
    }

    // >0x5    bytele    0    invalid byte order
    off = pageOff + 5
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      out = append(out, "invalid byte order")
    }

    // >0x5    bytele    1    LSB
    off = pageOff + 5
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) == 0x1)
    }
    if m1 {
      out = append(out, "LSB")
    }

    if m1 {
      // >>0x0    use   elf-le    
      off = pageOff + 0
      // uh oh unhandled kind

    }
    // >0x5    bytele    2    MSB
    off = pageOff + 5
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) == 0x2)
    }
    if m1 {
      out = append(out, "MSB")
    }

    if m1 {
      // >>0x0    use   \^elf-le    
      off = pageOff + 0
      // uh oh unhandled kind

    }
    // >0x4    bytele    80    
    off = pageOff + 4
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (int64(int8(iv)) < 0x80)
    }

    if m1 {
      // >>0x8    string    ">\x00"    (%s)
      off = pageOff + 8
      // uh oh unhandled kind
      if m2 {
        out = append(out, "(%s)")
      }

    }
    // >0x8    string    "\x00"    
    off = pageOff + 8
    // uh oh unhandled kind

    if m1 {
      // >>0x7    bytele    0    (SYSV)
      off = pageOff + 7
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }
      if m2 {
        out = append(out, "(SYSV)")
      }

      // >>0x7    bytele    1    (HP-UX)
      off = pageOff + 7
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x1)
      }
      if m2 {
        out = append(out, "(HP-UX)")
      }

      // >>0x7    bytele    2    (NetBSD)
      off = pageOff + 7
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x2)
      }
      if m2 {
        out = append(out, "(NetBSD)")
      }

      // >>0x7    bytele    3    (GNU/Linux)
      off = pageOff + 7
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x3)
      }
      if m2 {
        out = append(out, "(GNU/Linux)")
      }

      // >>0x7    bytele    4    (GNU/Hurd)
      off = pageOff + 7
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x4)
      }
      if m2 {
        out = append(out, "(GNU/Hurd)")
      }

      // >>0x7    bytele    5    (86Open)
      off = pageOff + 7
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x5)
      }
      if m2 {
        out = append(out, "(86Open)")
      }

      // >>0x7    bytele    6    (Solaris)
      off = pageOff + 7
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x6)
      }
      if m2 {
        out = append(out, "(Solaris)")
      }

      // >>0x7    bytele    7    (Monterey)
      off = pageOff + 7
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x7)
      }
      if m2 {
        out = append(out, "(Monterey)")
      }

      // >>0x7    bytele    8    (IRIX)
      off = pageOff + 7
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x8)
      }
      if m2 {
        out = append(out, "(IRIX)")
      }

      // >>0x7    bytele    9    (FreeBSD)
      off = pageOff + 7
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x9)
      }
      if m2 {
        out = append(out, "(FreeBSD)")
      }

      // >>0x7    bytele    a    (Tru64)
      off = pageOff + 7
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0xa)
      }
      if m2 {
        out = append(out, "(Tru64)")
      }

      // >>0x7    bytele    b    (Novell Modesto)
      off = pageOff + 7
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0xb)
      }
      if m2 {
        out = append(out, "(Novell Modesto)")
      }

      // >>0x7    bytele    c    (OpenBSD)
      off = pageOff + 7
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0xc)
      }
      if m2 {
        out = append(out, "(OpenBSD)")
      }

    }
    // >0x8    string    "\x02"    
    off = pageOff + 8
    // uh oh unhandled kind

    if m1 {
      // >>0x7    bytele    d    (OpenVMS)
      off = pageOff + 7
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0xd)
      }
      if m2 {
        out = append(out, "(OpenVMS)")
      }

      // >>0x7    bytele    61    (ARM)
      off = pageOff + 7
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x61)
      }
      if m2 {
        out = append(out, "(ARM)")
      }

      // >>0x7    bytele    ff    (embedded)
      off = pageOff + 7
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0xff)
      }
      if m2 {
        out = append(out, "(embedded)")
      }

    }
  }
  // 0x0    string    "@"    
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0x1    string    " echo off"    DOS batch file text
    off = pageOff + 1
    // uh oh unhandled kind
    if m1 {
      out = append(out, "DOS batch file text")
    }

    // >0x1    string    "echo off"    DOS batch file text
    off = pageOff + 1
    // uh oh unhandled kind
    if m1 {
      out = append(out, "DOS batch file text")
    }

    // >0x1    string    "rem"    DOS batch file text
    off = pageOff + 1
    // uh oh unhandled kind
    if m1 {
      out = append(out, "DOS batch file text")
    }

    // >0x1    string    "set "    DOS batch file text
    off = pageOff + 1
    // uh oh unhandled kind
    if m1 {
      out = append(out, "DOS batch file text")
    }

  }
  // 0x64    search/0xffff    "rxfuncadd"    
  off = pageOff + 100
  // uh oh unhandled kind

  // 0x64    search/0xffff    "say"    
  off = pageOff + 100
  // uh oh unhandled kind

  // 0x0    shortle    166    MS Windows COFF MIPS R4000 object file
  off = pageOff + 0
  {
    iv, ok := readUint16be(tb, off)
    m0 = ok && (uint64(iv) == 0x166)
  }
  if m0 {
    out = append(out, "MS Windows COFF MIPS R4000 object file")
  }

  // 0x0    shortle    184    MS Windows COFF Alpha object file
  off = pageOff + 0
  {
    iv, ok := readUint16be(tb, off)
    m0 = ok && (uint64(iv) == 0x184)
  }
  if m0 {
    out = append(out, "MS Windows COFF Alpha object file")
  }

  // 0x0    shortle    268    MS Windows COFF Motorola 68000 object file
  off = pageOff + 0
  {
    iv, ok := readUint16be(tb, off)
    m0 = ok && (uint64(iv) == 0x268)
  }
  if m0 {
    out = append(out, "MS Windows COFF Motorola 68000 object file")
  }

  // 0x0    shortle    1f0    MS Windows COFF PowerPC object file
  off = pageOff + 0
  {
    iv, ok := readUint16be(tb, off)
    m0 = ok && (uint64(iv) == 0x1f0)
  }
  if m0 {
    out = append(out, "MS Windows COFF PowerPC object file")
  }

  // 0x0    shortle    290    MS Windows COFF PA-RISC object file
  off = pageOff + 0
  {
    iv, ok := readUint16be(tb, off)
    m0 = ok && (uint64(iv) == 0x290)
  }
  if m0 {
    out = append(out, "MS Windows COFF PA-RISC object file")
  }

  // 0x0    string    "MZ"    
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0x18    shortle    40    MS-DOS executable
    off = pageOff + 24
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (int64(int16(iv)) < 0x40)
    }
    if m1 {
      out = append(out, "MS-DOS executable")
    }

    // >0x18    shortle    3f    
    off = pageOff + 24
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (int64(int16(iv)) > 0x3f)
    }

    if m1 {
      // >>(0x3c.longle)    string    "PE\x00\x00"    PE
      // uh oh indirect offset
      // uh oh unhandled kind
      if m2 {
        out = append(out, "PE")
      }

      if m2 {
        // >>>(0x3c.longle+24)    shortle    10b    \b32 executable
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x10b)
        }
        if m3 {
          out = append(out, "\\b32 executable")
        }

        // >>>(0x3c.longle+24)    shortle    20b    \b32+ executable
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x20b)
        }
        if m3 {
          out = append(out, "\\b32+ executable")
        }

        // >>>(0x3c.longle+24)    shortle    107    ROM image
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x107)
        }
        if m3 {
          out = append(out, "ROM image")
        }

        // >>>(0x3c.longle+24)    default    Unknown PE signature
        // uh oh indirect offset
        // uh oh unhandled kind
        if m3 {
          out = append(out, "Unknown PE signature")
        }

        if m3 {
          // >>>>&0x0    shortle    0    0x%x
          off = pageOff + 0
          {
            iv, ok := readUint16be(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }
          if m4 {
            out = append(out, "0x%x")
          }

        }
        // >>>(0x3c.longle+22)    shortle    0&0x2000    (DLL)
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (int64(int16(iv)) > 0x0)
        }
        if m3 {
          out = append(out, "(DLL)")
        }

        // >>>(0x3c.longle+92)    shortle    1    (native)
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x1)
        }
        if m3 {
          out = append(out, "(native)")
        }

        // >>>(0x3c.longle+92)    shortle    2    (GUI)
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x2)
        }
        if m3 {
          out = append(out, "(GUI)")
        }

        // >>>(0x3c.longle+92)    shortle    3    (console)
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x3)
        }
        if m3 {
          out = append(out, "(console)")
        }

        // >>>(0x3c.longle+92)    shortle    7    (POSIX)
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x7)
        }
        if m3 {
          out = append(out, "(POSIX)")
        }

        // >>>(0x3c.longle+92)    shortle    9    (Windows CE)
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x9)
        }
        if m3 {
          out = append(out, "(Windows CE)")
        }

        // >>>(0x3c.longle+92)    shortle    a    (EFI application)
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0xa)
        }
        if m3 {
          out = append(out, "(EFI application)")
        }

        // >>>(0x3c.longle+92)    shortle    b    (EFI boot service driver)
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0xb)
        }
        if m3 {
          out = append(out, "(EFI boot service driver)")
        }

        // >>>(0x3c.longle+92)    shortle    c    (EFI runtime driver)
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0xc)
        }
        if m3 {
          out = append(out, "(EFI runtime driver)")
        }

        // >>>(0x3c.longle+92)    shortle    d    (EFI ROM)
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0xd)
        }
        if m3 {
          out = append(out, "(EFI ROM)")
        }

        // >>>(0x3c.longle+92)    shortle    e    (XBOX)
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0xe)
        }
        if m3 {
          out = append(out, "(XBOX)")
        }

        // >>>(0x3c.longle+92)    shortle    f    (Windows boot application)
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0xf)
        }
        if m3 {
          out = append(out, "(Windows boot application)")
        }

        // >>>(0x3c.longle+92)    default    (Unknown subsystem
        // uh oh indirect offset
        // uh oh unhandled kind
        if m3 {
          out = append(out, "(Unknown subsystem")
        }

        if m3 {
          // >>>>&0x0    shortle    0    0x%x)
          off = pageOff + 0
          {
            iv, ok := readUint16be(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }
          if m4 {
            out = append(out, "0x%x)")
          }

        }
        // >>>(0x3c.longle+4)    shortle    14c    Intel 80386
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x14c)
        }
        if m3 {
          out = append(out, "Intel 80386")
        }

        // >>>(0x3c.longle+4)    shortle    166    MIPS R4000
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x166)
        }
        if m3 {
          out = append(out, "MIPS R4000")
        }

        // >>>(0x3c.longle+4)    shortle    168    MIPS R10000
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x168)
        }
        if m3 {
          out = append(out, "MIPS R10000")
        }

        // >>>(0x3c.longle+4)    shortle    184    Alpha
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x184)
        }
        if m3 {
          out = append(out, "Alpha")
        }

        // >>>(0x3c.longle+4)    shortle    1a2    Hitachi SH3
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x1a2)
        }
        if m3 {
          out = append(out, "Hitachi SH3")
        }

        // >>>(0x3c.longle+4)    shortle    1a6    Hitachi SH4
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x1a6)
        }
        if m3 {
          out = append(out, "Hitachi SH4")
        }

        // >>>(0x3c.longle+4)    shortle    1c0    ARM
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x1c0)
        }
        if m3 {
          out = append(out, "ARM")
        }

        // >>>(0x3c.longle+4)    shortle    1c2    ARM Thumb
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x1c2)
        }
        if m3 {
          out = append(out, "ARM Thumb")
        }

        // >>>(0x3c.longle+4)    shortle    1c4    ARMv7 Thumb
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x1c4)
        }
        if m3 {
          out = append(out, "ARMv7 Thumb")
        }

        // >>>(0x3c.longle+4)    shortle    1f0    PowerPC
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x1f0)
        }
        if m3 {
          out = append(out, "PowerPC")
        }

        // >>>(0x3c.longle+4)    shortle    200    Intel Itanium
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x200)
        }
        if m3 {
          out = append(out, "Intel Itanium")
        }

        // >>>(0x3c.longle+4)    shortle    266    MIPS16
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x266)
        }
        if m3 {
          out = append(out, "MIPS16")
        }

        // >>>(0x3c.longle+4)    shortle    268    Motorola 68000
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x268)
        }
        if m3 {
          out = append(out, "Motorola 68000")
        }

        // >>>(0x3c.longle+4)    shortle    290    PA-RISC
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x290)
        }
        if m3 {
          out = append(out, "PA-RISC")
        }

        // >>>(0x3c.longle+4)    shortle    366    MIPSIV
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x366)
        }
        if m3 {
          out = append(out, "MIPSIV")
        }

        // >>>(0x3c.longle+4)    shortle    466    MIPS16 with FPU
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x466)
        }
        if m3 {
          out = append(out, "MIPS16 with FPU")
        }

        // >>>(0x3c.longle+4)    shortle    ebc    EFI byte code
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0xebc)
        }
        if m3 {
          out = append(out, "EFI byte code")
        }

        // >>>(0x3c.longle+4)    shortle    8664    x86-64
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x8664)
        }
        if m3 {
          out = append(out, "x86-64")
        }

        // >>>(0x3c.longle+4)    shortle    c0ee    MSIL
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0xc0ee)
        }
        if m3 {
          out = append(out, "MSIL")
        }

        // >>>(0x3c.longle+4)    default    Unknown processor type
        // uh oh indirect offset
        // uh oh unhandled kind
        if m3 {
          out = append(out, "Unknown processor type")
        }

        if m3 {
          // >>>>&0x0    shortle    0    0x%x
          off = pageOff + 0
          {
            iv, ok := readUint16be(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }
          if m4 {
            out = append(out, "0x%x")
          }

        }
        // >>>(0x3c.longle+22)    shortle    0&0x200    (stripped to external PDB)
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (int64(int16(iv)) > 0x0)
        }
        if m3 {
          out = append(out, "(stripped to external PDB)")
        }

        // >>>(0x3c.longle+22)    shortle    0&0x1000    system file
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (int64(int16(iv)) > 0x0)
        }
        if m3 {
          out = append(out, "system file")
        }

        // >>>(0x3c.longle+24)    shortle    10b    
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x10b)
        }

        if m3 {
          // >>>>(0x3c.longle+232)    longle    0    Mono/.Net assembly
          // uh oh indirect offset
          {
            iv, ok := readUint32be(tb, off)
            m4 = ok && (int64(int32(iv)) > 0x0)
          }
          if m4 {
            out = append(out, "Mono/.Net assembly")
          }

        }
        // >>>(0x3c.longle+24)    shortle    20b    
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x20b)
        }

        if m3 {
          // >>>>(0x3c.longle+248)    longle    0    Mono/.Net assembly
          // uh oh indirect offset
          {
            iv, ok := readUint32be(tb, off)
            m4 = ok && (int64(int32(iv)) > 0x0)
          }
          if m4 {
            out = append(out, "Mono/.Net assembly")
          }

        }
        // >>>(0x8.shortle*16)    string    "32STUB"    \b, 32rtm DOS extender
        // uh oh indirect offset
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, 32rtm DOS extender")
        }

        // >>>(0x8.shortle*16)    string    "32STUB"    \b, for MS Windows
        // uh oh indirect offset
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, for MS Windows")
        }

        // >>>(0x3c.longle+248)    string    "UPX0"    \b, UPX compressed
        // uh oh indirect offset
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, UPX compressed")
        }

        // >>>(0x3c.longle+248)    search/0x140    "PEC2"    \b, PECompact2 compressed
        // uh oh indirect offset
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, PECompact2 compressed")
        }

        // >>>(0x3c.longle+248)    search/0x140    "UPX2"    
        // uh oh indirect offset
        // uh oh unhandled kind

        if m3 {
          // >>>>(&0x10.longle+(-4))    string    "PK\x03\x04"    \b, ZIP self-extracting archive (Info-Zip)
          // uh oh indirect offset
          // uh oh unhandled kind
          if m4 {
            out = append(out, "\\b, ZIP self-extracting archive (Info-Zip)")
          }

        }
        // >>>(0x3c.longle+248)    search/0x140    ".idata"    
        // uh oh indirect offset
        // uh oh unhandled kind

        if m3 {
          // >>>>(&0xe.longle+(-4))    string    "PK\x03\x04"    \b, ZIP self-extracting archive (Info-Zip)
          // uh oh indirect offset
          // uh oh unhandled kind
          if m4 {
            out = append(out, "\\b, ZIP self-extracting archive (Info-Zip)")
          }

          // >>>>(&0xe.longle+(-4))    string    "ZZ0"    \b, ZZip self-extracting archive
          // uh oh indirect offset
          // uh oh unhandled kind
          if m4 {
            out = append(out, "\\b, ZZip self-extracting archive")
          }

          // >>>>(&0xe.longle+(-4))    string    "ZZ1"    \b, ZZip self-extracting archive
          // uh oh indirect offset
          // uh oh unhandled kind
          if m4 {
            out = append(out, "\\b, ZZip self-extracting archive")
          }

        }
        // >>>(0x3c.longle+248)    search/0x140    ".rsrc"    
        // uh oh indirect offset
        // uh oh unhandled kind

        if m3 {
          // >>>>(&0xf.longle+(-4))    string    "a\\\x04\x05"    \b, WinHKI self-extracting archive
          // uh oh indirect offset
          // uh oh unhandled kind
          if m4 {
            out = append(out, "\\b, WinHKI self-extracting archive")
          }

          // >>>>(&0xf.longle+(-4))    string    "Rar!"    \b, RAR self-extracting archive
          // uh oh indirect offset
          // uh oh unhandled kind
          if m4 {
            out = append(out, "\\b, RAR self-extracting archive")
          }

          // >>>>(&0xf.longle+(-4))    search/0x3000    "MSCF"    \b, InstallShield self-extracting archive
          // uh oh indirect offset
          // uh oh unhandled kind
          if m4 {
            out = append(out, "\\b, InstallShield self-extracting archive")
          }

          // >>>>(&0xf.longle+(-4))    search/0x20    "Nullsoft"    \b, Nullsoft Installer self-extracting archive
          // uh oh indirect offset
          // uh oh unhandled kind
          if m4 {
            out = append(out, "\\b, Nullsoft Installer self-extracting archive")
          }

        }
        // >>>(0x3c.longle+248)    search/0x140    ".data"    
        // uh oh indirect offset
        // uh oh unhandled kind

        if m3 {
          // >>>>(&0xf.longle)    string    "WEXTRACT"    \b, MS CAB-Installer self-extracting archive
          // uh oh indirect offset
          // uh oh unhandled kind
          if m4 {
            out = append(out, "\\b, MS CAB-Installer self-extracting archive")
          }

        }
        // >>>(0x3c.longle+248)    search/0x140    ".petite\x00"    \b, Petite compressed
        // uh oh indirect offset
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, Petite compressed")
        }

        if m3 {
          // >>>>(0x3c.longle+247)    bytele    0    
          // uh oh indirect offset
          {
            iv, ok := readUint8be(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }

          if m4 {
            // >>>>>(&0x104.longle+(-4))    string    "=!sfx!"    \b, ACE self-extracting archive
            // uh oh indirect offset
            // uh oh unhandled kind
            if m5 {
              out = append(out, "\\b, ACE self-extracting archive")
            }

          }
        }
        // >>>(0x3c.longle+248)    search/0x140    ".WISE"    \b, WISE installer self-extracting archive
        // uh oh indirect offset
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, WISE installer self-extracting archive")
        }

        // >>>(0x3c.longle+248)    search/0x140    ".dz\x00\x00\x00"    \b, Dzip self-extracting archive
        // uh oh indirect offset
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, Dzip self-extracting archive")
        }

        // >>>&(0x3c.longle+248)    search/0x100    "_winzip_"    \b, ZIP self-extracting archive (WinZip)
        // uh oh indirect offset
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, ZIP self-extracting archive (WinZip)")
        }

        // >>>&(0x3c.longle+248)    search/0x100    "SharedD"    \b, Microsoft Installer self-extracting archive
        // uh oh indirect offset
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, Microsoft Installer self-extracting archive")
        }

        // >>>0x30    string    "Inno"    \b, InnoSetup self-extracting archive
        off = pageOff + 48
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, InnoSetup self-extracting archive")
        }

      }
      // >>(0x3c.longle)    string    "PE\x00\x00"    MS-DOS executable
      // uh oh indirect offset
      // uh oh unhandled kind
      if m2 {
        out = append(out, "MS-DOS executable")
      }

      // >>(0x3c.longle)    string    "NE"    \b, NE
      // uh oh indirect offset
      // uh oh unhandled kind
      if m2 {
        out = append(out, "\\b, NE")
      }

      if m2 {
        // >>>(0x3c.longle+54)    bytele    1    for OS/2 1.x
        // uh oh indirect offset
        {
          iv, ok := readUint8be(tb, off)
          m3 = ok && (uint64(iv) == 0x1)
        }
        if m3 {
          out = append(out, "for OS/2 1.x")
        }

        // >>>(0x3c.longle+54)    bytele    2    for MS Windows 3.x
        // uh oh indirect offset
        {
          iv, ok := readUint8be(tb, off)
          m3 = ok && (uint64(iv) == 0x2)
        }
        if m3 {
          out = append(out, "for MS Windows 3.x")
        }

        // >>>(0x3c.longle+54)    bytele    3    for MS-DOS
        // uh oh indirect offset
        {
          iv, ok := readUint8be(tb, off)
          m3 = ok && (uint64(iv) == 0x3)
        }
        if m3 {
          out = append(out, "for MS-DOS")
        }

        // >>>(0x3c.longle+54)    bytele    4    for Windows 386
        // uh oh indirect offset
        {
          iv, ok := readUint8be(tb, off)
          m3 = ok && (uint64(iv) == 0x4)
        }
        if m3 {
          out = append(out, "for Windows 386")
        }

        // >>>(0x3c.longle+54)    bytele    5    for Borland Operating System Services
        // uh oh indirect offset
        {
          iv, ok := readUint8be(tb, off)
          m3 = ok && (uint64(iv) == 0x5)
        }
        if m3 {
          out = append(out, "for Borland Operating System Services")
        }

        // >>>(0x3c.longle+54)    default    
        // uh oh indirect offset
        // uh oh unhandled kind

        if m3 {
          // >>>>(0x3c.longle+54)    bytele    0    (unknown OS %x)
          // uh oh indirect offset
          {
            iv, ok := readUint8be(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }
          if m4 {
            out = append(out, "(unknown OS %x)")
          }

        }
        // >>>(0x3c.longle+54)    bytele    81    for MS-DOS, Phar Lap DOS extender
        // uh oh indirect offset
        {
          iv, ok := readUint8be(tb, off)
          m3 = ok && (uint64(iv) == 0x81)
        }
        if m3 {
          out = append(out, "for MS-DOS, Phar Lap DOS extender")
        }

        // >>>(0x3c.longle+12)    shortle    8002&0x8003    (DLL)
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x8002)
        }
        if m3 {
          out = append(out, "(DLL)")
        }

        // >>>(0x3c.longle+12)    shortle    8001&0x8003    (driver)
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x8001)
        }
        if m3 {
          out = append(out, "(driver)")
        }

        // >>>&(&0x24.shortle-1)    string    "ARJSFX"    \b, ARJ self-extracting archive
        // uh oh indirect offset
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, ARJ self-extracting archive")
        }

        // >>>(0x3c.longle+112)    search/0x80    "WinZip(R) Self-Extractor"    \b, ZIP self-extracting archive (WinZip)
        // uh oh indirect offset
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, ZIP self-extracting archive (WinZip)")
        }

      }
      // >>(0x3c.longle)    string    "LX\x00\x00"    \b, LX
      // uh oh indirect offset
      // uh oh unhandled kind
      if m2 {
        out = append(out, "\\b, LX")
      }

      if m2 {
        // >>>(0x3c.longle+10)    shortle    1    (unknown OS)
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (int64(int16(iv)) < 0x1)
        }
        if m3 {
          out = append(out, "(unknown OS)")
        }

        // >>>(0x3c.longle+10)    shortle    1    for OS/2
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x1)
        }
        if m3 {
          out = append(out, "for OS/2")
        }

        // >>>(0x3c.longle+10)    shortle    2    for MS Windows
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x2)
        }
        if m3 {
          out = append(out, "for MS Windows")
        }

        // >>>(0x3c.longle+10)    shortle    3    for DOS
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x3)
        }
        if m3 {
          out = append(out, "for DOS")
        }

        // >>>(0x3c.longle+10)    shortle    3    (unknown OS)
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (int64(int16(iv)) > 0x3)
        }
        if m3 {
          out = append(out, "(unknown OS)")
        }

        // >>>(0x3c.longle+16)    longle    8000&0x28000    (DLL)
        // uh oh indirect offset
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x8000)
        }
        if m3 {
          out = append(out, "(DLL)")
        }

        // >>>(0x3c.longle+16)    longle    0&0x20000    (device driver)
        // uh oh indirect offset
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (int64(int32(iv)) > 0x0)
        }
        if m3 {
          out = append(out, "(device driver)")
        }

        // >>>(0x3c.longle+16)    longle    300&0x300    (GUI)
        // uh oh indirect offset
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x300)
        }
        if m3 {
          out = append(out, "(GUI)")
        }

        // >>>(0x3c.longle+16)    longle    300&0x28300    (console)
        // uh oh indirect offset
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (int64(int32(iv)) < 0x300)
        }
        if m3 {
          out = append(out, "(console)")
        }

        // >>>(0x3c.longle+8)    shortle    1    i80286
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x1)
        }
        if m3 {
          out = append(out, "i80286")
        }

        // >>>(0x3c.longle+8)    shortle    2    i80386
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x2)
        }
        if m3 {
          out = append(out, "i80386")
        }

        // >>>(0x3c.longle+8)    shortle    3    i80486
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x3)
        }
        if m3 {
          out = append(out, "i80486")
        }

        // >>>(0x8.shortle*16)    string    "emx"    \b, emx
        // uh oh indirect offset
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, emx")
        }

        if m3 {
          // >>>>&0x1    string    "x"    %s
          off = pageOff + 1
          // uh oh unhandled kind
          if m4 {
            out = append(out, "%s")
          }

        }
        // >>>&(&0x54.longle-3)    string    "arjsfx"    \b, ARJ self-extracting archive
        // uh oh indirect offset
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, ARJ self-extracting archive")
        }

      }
      // >>(0x3c.longle)    string    "W3"    \b, W3 for MS Windows
      // uh oh indirect offset
      // uh oh unhandled kind
      if m2 {
        out = append(out, "\\b, W3 for MS Windows")
      }

      // >>(0x3c.longle)    string    "LE\x00\x00"    \b, LE executable
      // uh oh indirect offset
      // uh oh unhandled kind
      if m2 {
        out = append(out, "\\b, LE executable")
      }

      if m2 {
        // >>>(0x3c.longle+10)    shortle    1    
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x1)
        }

        if m3 {
          // >>>>0x240    search/0x100    "DOS/4G"    for MS-DOS, DOS4GW DOS extender
          off = pageOff + 576
          // uh oh unhandled kind
          if m4 {
            out = append(out, "for MS-DOS, DOS4GW DOS extender")
          }

          // >>>>0x240    search/0x200    "WATCOM C/C++"    for MS-DOS, DOS4GW DOS extender
          off = pageOff + 576
          // uh oh unhandled kind
          if m4 {
            out = append(out, "for MS-DOS, DOS4GW DOS extender")
          }

          // >>>>0x440    search/0x100    "CauseWay DOS Extender"    for MS-DOS, CauseWay DOS extender
          off = pageOff + 1088
          // uh oh unhandled kind
          if m4 {
            out = append(out, "for MS-DOS, CauseWay DOS extender")
          }

          // >>>>0x40    search/0x40    "PMODE/W"    for MS-DOS, PMODE/W DOS extender
          off = pageOff + 64
          // uh oh unhandled kind
          if m4 {
            out = append(out, "for MS-DOS, PMODE/W DOS extender")
          }

          // >>>>0x40    search/0x40    "STUB/32A"    for MS-DOS, DOS/32A DOS extender (stub)
          off = pageOff + 64
          // uh oh unhandled kind
          if m4 {
            out = append(out, "for MS-DOS, DOS/32A DOS extender (stub)")
          }

          // >>>>0x40    search/0x80    "STUB/32C"    for MS-DOS, DOS/32A DOS extender (configurable stub)
          off = pageOff + 64
          // uh oh unhandled kind
          if m4 {
            out = append(out, "for MS-DOS, DOS/32A DOS extender (configurable stub)")
          }

          // >>>>0x40    search/0x80    "DOS/32A"    for MS-DOS, DOS/32A DOS extender (embedded)
          off = pageOff + 64
          // uh oh unhandled kind
          if m4 {
            out = append(out, "for MS-DOS, DOS/32A DOS extender (embedded)")
          }

          // >>>>&0x24    longle    50    
          off = pageOff + 36
          {
            iv, ok := readUint32be(tb, off)
            m4 = ok && (int64(int32(iv)) < 0x50)
          }

          if m4 {
            // >>>>>(&0x4c.longle)    string    "\xfc\xb8WATCOM"    
            // uh oh indirect offset
            // uh oh unhandled kind

            if m5 {
              // >>>>>>&0x0    search/0x8    "3\xdbf\xb9"    \b, 32Lite compressed
              off = pageOff + 0
              // uh oh unhandled kind
              if m6 {
                out = append(out, "\\b, 32Lite compressed")
              }

            }
          }
        }
        // >>>(0x3c.longle+10)    shortle    2    for MS Windows
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x2)
        }
        if m3 {
          out = append(out, "for MS Windows")
        }

        // >>>(0x3c.longle+10)    shortle    3    for DOS
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x3)
        }
        if m3 {
          out = append(out, "for DOS")
        }

        // >>>(0x3c.longle+10)    shortle    4    for MS Windows (VxD)
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x4)
        }
        if m3 {
          out = append(out, "for MS Windows (VxD)")
        }

        // >>>(&0x7c.longle+38)    string    "UPX"    \b, UPX compressed
        // uh oh indirect offset
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, UPX compressed")
        }

        // >>>&(&0x54.longle-3)    string    "UNACE"    \b, ACE self-extracting archive
        // uh oh indirect offset
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, ACE self-extracting archive")
        }

      }
      // >>0x3c    longle    20000000    
      off = pageOff + 60
      {
        iv, ok := readUint32be(tb, off)
        m2 = ok && (int64(int32(iv)) > 0x20000000)
      }

      if m2 {
        // >>>(0x4.shortle*512)    shortle    14c    \b, MZ for MS-DOS
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) != 0x14c)
        }
        if m3 {
          out = append(out, "\\b, MZ for MS-DOS")
        }

      }
    }
    // >0x2    longle    0    
    off = pageOff + 2
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) != 0x0)
    }

    if m1 {
      // >>0x18    shortle    40    
      off = pageOff + 24
      {
        iv, ok := readUint16be(tb, off)
        m2 = ok && (int64(int16(iv)) < 0x40)
      }

      if m2 {
        // >>>(0x4.shortle*512)    shortle    14c    
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) != 0x14c)
        }

        if m3 {
          // >>>>&(0x2.shortle-514)    string    "LE"    
          // uh oh indirect offset
          // uh oh unhandled kind

          if m4 {
            // >>>>>&0x-2    string    "BW"    \b, MZ for MS-DOS
            off = pageOff + -2
            // uh oh unhandled kind
            if m5 {
              out = append(out, "\\b, MZ for MS-DOS")
            }

          }
          // >>>>&(0x2.shortle-514)    string    "LE"    \b, LE
          // uh oh indirect offset
          // uh oh unhandled kind
          if m4 {
            out = append(out, "\\b, LE")
          }

          if m4 {
            // >>>>>0x240    search/0x100    "DOS/4G"    for MS-DOS, DOS4GW DOS extender
            off = pageOff + 576
            // uh oh unhandled kind
            if m5 {
              out = append(out, "for MS-DOS, DOS4GW DOS extender")
            }

          }
          // >>>>&(0x2.shortle-514)    string    "BW"    
          // uh oh indirect offset
          // uh oh unhandled kind

          if m4 {
            // >>>>>0x240    search/0x100    "DOS/4G"    \b, LE for MS-DOS, DOS4GW DOS extender (embedded)
            off = pageOff + 576
            // uh oh unhandled kind
            if m5 {
              out = append(out, "\\b, LE for MS-DOS, DOS4GW DOS extender (embedded)")
            }

            // >>>>>0x240    search/0x100    "!DOS/4G"    \b, BW collection for MS-DOS
            off = pageOff + 576
            // uh oh unhandled kind
            if m5 {
              out = append(out, "\\b, BW collection for MS-DOS")
            }

          }
        }
      }
    }
    // >(0x4.shortle*512)    shortle    14c    \b, COFF
    // uh oh indirect offset
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x14c)
    }
    if m1 {
      out = append(out, "\\b, COFF")
    }

    if m1 {
      // >>(0x8.shortle*16)    string    "go32stub"    for MS-DOS, DJGPP go32 DOS extender
      // uh oh indirect offset
      // uh oh unhandled kind
      if m2 {
        out = append(out, "for MS-DOS, DJGPP go32 DOS extender")
      }

      // >>(0x8.shortle*16)    string    "emx"    
      // uh oh indirect offset
      // uh oh unhandled kind

      if m2 {
        // >>>&0x1    string    "x"    for DOS, Win or OS/2, emx %s
        off = pageOff + 1
        // uh oh unhandled kind
        if m3 {
          out = append(out, "for DOS, Win or OS/2, emx %s")
        }

      }
      // >>&(&0x42.longle-3)    bytele    0    
      // uh oh indirect offset
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }

      if m2 {
        // >>>&0x26    string    "UPX"    \b, UPX compressed
        off = pageOff + 38
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, UPX compressed")
        }

      }
      // >>&0x2c    search/0xa0    ".text"    
      off = pageOff + 44
      // uh oh unhandled kind

      if m2 {
        // >>>&0xb    longle    2000    
        off = pageOff + 11
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (int64(int32(iv)) < 0x2000)
        }

        if m3 {
          // >>>>&0x0    longle    6000    \b, 32lite compressed
          off = pageOff + 0
          {
            iv, ok := readUint32be(tb, off)
            m4 = ok && (int64(int32(iv)) > 0x6000)
          }
          if m4 {
            out = append(out, "\\b, 32lite compressed")
          }

        }
      }
    }
    // >(0x8.shortle*16)    string    "$WdX"    \b, WDos/X DOS extender
    // uh oh indirect offset
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, WDos/X DOS extender")
    }

    // >0x35    string    "\x8e\xc0\xb9\b\x00\xf3\xa5Ju\xeb\x8e\xd83\xff\xbe0\x00\x05"    \b, aPack compressed
    off = pageOff + 53
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, aPack compressed")
    }

    // >0xe7    string    "LH/2 "    Self-Extract \b, %s
    off = pageOff + 231
    // uh oh unhandled kind
    if m1 {
      out = append(out, "Self-Extract \\b, %s")
    }

    // >0x1c    string    "UC2X"    \b, UCEXE compressed
    off = pageOff + 28
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, UCEXE compressed")
    }

    // >0x1c    string    "WWP "    \b, WWPACK compressed
    off = pageOff + 28
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, WWPACK compressed")
    }

    // >0x1c    string    "RJSX"    \b, ARJ self-extracting archive
    off = pageOff + 28
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, ARJ self-extracting archive")
    }

    // >0x1c    string    "diet"    \b, diet compressed
    off = pageOff + 28
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, diet compressed")
    }

    // >0x1c    string    "LZ09"    \b, LZEXE v0.90 compressed
    off = pageOff + 28
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, LZEXE v0.90 compressed")
    }

    // >0x1c    string    "LZ91"    \b, LZEXE v0.91 compressed
    off = pageOff + 28
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, LZEXE v0.91 compressed")
    }

    // >0x1c    string    "tz"    \b, TinyProg compressed
    off = pageOff + 28
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, TinyProg compressed")
    }

    // >0x1e    string    "Copyright 1989-1990 PKWARE Inc."    Self-extracting PKZIP archive
    off = pageOff + 30
    // uh oh unhandled kind
    if m1 {
      out = append(out, "Self-extracting PKZIP archive")
    }

    // >0x1e    string    "PKLITE Copr."    Self-extracting PKZIP archive
    off = pageOff + 30
    // uh oh unhandled kind
    if m1 {
      out = append(out, "Self-extracting PKZIP archive")
    }

    // >0x20    search/0xe0    "aRJsfX"    \b, ARJ self-extracting archive
    off = pageOff + 32
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, ARJ self-extracting archive")
    }

    // >0x20    string    "AIN"    
    off = pageOff + 32
    // uh oh unhandled kind

    if m1 {
      // >>0x23    string    "2"    \b, AIN 2.x compressed
      off = pageOff + 35
      // uh oh unhandled kind
      if m2 {
        out = append(out, "\\b, AIN 2.x compressed")
      }

      // >>0x23    string    "<2"    \b, AIN 1.x compressed
      off = pageOff + 35
      // uh oh unhandled kind
      if m2 {
        out = append(out, "\\b, AIN 1.x compressed")
      }

      // >>0x23    string    ">2"    \b, AIN 1.x compressed
      off = pageOff + 35
      // uh oh unhandled kind
      if m2 {
        out = append(out, "\\b, AIN 1.x compressed")
      }

    }
    // >0x24    string    "LHa's SFX"    \b, LHa self-extracting archive
    off = pageOff + 36
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, LHa self-extracting archive")
    }

    // >0x24    string    "LHA's SFX"    \b, LHa self-extracting archive
    off = pageOff + 36
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, LHa self-extracting archive")
    }

    // >0x24    string    " $ARX"    \b, ARX self-extracting archive
    off = pageOff + 36
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, ARX self-extracting archive")
    }

    // >0x24    string    " $LHarc"    \b, LHarc self-extracting archive
    off = pageOff + 36
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, LHarc self-extracting archive")
    }

    // >0x20    string    "SFX by LARC"    \b, LARC self-extracting archive
    off = pageOff + 32
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, LARC self-extracting archive")
    }

    // >0x40    string    "aPKG"    \b, aPackage self-extracting archive
    off = pageOff + 64
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, aPackage self-extracting archive")
    }

    // >0x64    string    "W Collis\x00\x00"    \b, Compack compressed
    off = pageOff + 100
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, Compack compressed")
    }

    // >0x7a    string    "Windows self-extracting ZIP"    \b, ZIP self-extracting archive
    off = pageOff + 122
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, ZIP self-extracting archive")
    }

    if m1 {
      // >>&0xf4    search/0x140    "\x00@\x01\x00"    
      off = pageOff + 244
      // uh oh unhandled kind

      if m2 {
        // >>>(&0x0.longle+(4))    string    "MSCF"    \b, WinHKI CAB self-extracting archive
        // uh oh indirect offset
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, WinHKI CAB self-extracting archive")
        }

      }
    }
    // >0x666    string    "-lh5-"    \b, LHa self-extracting archive v2.13S
    off = pageOff + 1638
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, LHa self-extracting archive v2.13S")
    }

    // >0x17888    string    "Rar!"    \b, RAR self-extracting archive
    off = pageOff + 96392
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, RAR self-extracting archive")
    }

    // >(0x4.shortle*512)    longle    0    
    // uh oh indirect offset
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }

    if m1 {
      // >>&(0x2.shortle-517)    bytele    0    
      // uh oh indirect offset
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }

      if m2 {
        // >>>&0x0    string    "PK\x03\x04"    \b, ZIP self-extracting archive
        off = pageOff + 0
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, ZIP self-extracting archive")
        }

        // >>>&0x0    string    "Rar!"    \b, RAR self-extracting archive
        off = pageOff + 0
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, RAR self-extracting archive")
        }

        // >>>&0x0    string    "=!\x11"    \b, AIN 2.x self-extracting archive
        off = pageOff + 0
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, AIN 2.x self-extracting archive")
        }

        // >>>&0x0    string    "=!\x12"    \b, AIN 2.x self-extracting archive
        off = pageOff + 0
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, AIN 2.x self-extracting archive")
        }

        // >>>&0x0    string    "=!\x17"    \b, AIN 1.x self-extracting archive
        off = pageOff + 0
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, AIN 1.x self-extracting archive")
        }

        // >>>&0x0    string    "=!\x18"    \b, AIN 1.x self-extracting archive
        off = pageOff + 0
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, AIN 1.x self-extracting archive")
        }

        // >>>&0x7    search/0x190    "**ACE**"    \b, ACE self-extracting archive
        off = pageOff + 7
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, ACE self-extracting archive")
        }

        // >>>&0x0    search/0x480    "UC2SFX Header"    \b, UC2 self-extracting archive
        off = pageOff + 0
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, UC2 self-extracting archive")
        }

      }
    }
    // >(0x8.shortle*16)    search/0x20    "PKSFX"    \b, ZIP self-extracting archive (PKZIP)
    // uh oh indirect offset
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, ZIP self-extracting archive (PKZIP)")
    }

    // >0xc289    string    "y\xff\x80\xffv\xff"    \b, CODEC archive v3.21
    off = pageOff + 49801
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, CODEC archive v3.21")
    }

    if m1 {
      // >>0xc2a0    shortle    1    \b, 1 file
      off = pageOff + 49824
      {
        iv, ok := readUint16be(tb, off)
        m2 = ok && (uint64(iv) == 0x1)
      }
      if m2 {
        out = append(out, "\\b, 1 file")
      }

      // >>0xc2a0    shortle    1    \b, %u files
      off = pageOff + 49824
      {
        iv, ok := readUint16be(tb, off)
        m2 = ok && (int64(int16(iv)) > 0x1)
      }
      if m2 {
        out = append(out, "\\b, %u files")
      }

    }
  }
  // 0x0    string    "KCF"    FreeDOS KEYBoard Layout collection
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "FreeDOS KEYBoard Layout collection")
  }

  if m0 {
    // >0x3    ushortle    0    \b, version 0x%x
    off = pageOff + 3
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      out = append(out, "\\b, version 0x%x")
    }

    // >0x6    ubytele    0    
    off = pageOff + 6
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (int64(int8(iv)) > 0x0)
    }

    if m1 {
      // >>0x7    string    ">\x00"    \b, author=%-.14s
      off = pageOff + 7
      // uh oh unhandled kind
      if m2 {
        out = append(out, "\\b, author=%-.14s")
      }

      // >>0x7    search/0xfe    "\xff"    \b, info=
      off = pageOff + 7
      // uh oh unhandled kind
      if m2 {
        out = append(out, "\\b, info=")
      }

      if m2 {
        // >>>&0x0    string    "x"    \b%-.15s
        off = pageOff + 0
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b%-.15s")
        }

      }
    }
  }
  // 0x0    string    "KLF"    FreeDOS KEYBoard Layout file
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "FreeDOS KEYBoard Layout file")
  }

  if m0 {
    // >0x3    ushortle    0    \b, version 0x%x
    off = pageOff + 3
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      out = append(out, "\\b, version 0x%x")
    }

    // >0x5    ubytele    0    
    off = pageOff + 5
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (int64(int8(iv)) > 0x0)
    }

    if m1 {
      // >>0x8    string    "x"    \b, name=%-.2s
      off = pageOff + 8
      // uh oh unhandled kind
      if m2 {
        out = append(out, "\\b, name=%-.2s")
      }

    }
  }
  // 0x0    string    "\xffKEYB   \x00\x00\x00\x00"    
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0xc    string    "\x00\x00\x00\x00`\x04\xf0"    MS-DOS KEYBoard Layout file
    off = pageOff + 12
    // uh oh unhandled kind
    if m1 {
      out = append(out, "MS-DOS KEYBoard Layout file")
    }

  }
  // 0x0    uquadle    ffffffff&0x7a0ffffffff    
  off = pageOff + 0
  {
    iv, ok := readUint64be(tb, off)
    m0 = ok && (uint64(iv) == 0xffffffff)
  }

  if m0 {
    // >0x0    use   msdos-driver    
    off = pageOff + 0
    // uh oh unhandled kind

  }
  // 0x0    uquadle    513c00000000012    
  off = pageOff + 0
  {
    iv, ok := readUint64be(tb, off)
    m0 = ok && (uint64(iv) == 0x513c00000000012)
  }

  if m0 {
    // >0x0    use   msdos-driver    
    off = pageOff + 0
    // uh oh unhandled kind

  }
  // 0x0    uquadle    32f28000ffff0016    
  off = pageOff + 0
  {
    iv, ok := readUint64be(tb, off)
    m0 = ok && (uint64(iv) == 0x32f28000ffff0016)
  }

  if m0 {
    // >0x0    use   msdos-driver    
    off = pageOff + 0
    // uh oh unhandled kind

  }
  // 0x0    uquadle    7f00000000ffff    
  off = pageOff + 0
  {
    iv, ok := readUint64be(tb, off)
    m0 = ok && (uint64(iv) == 0x7f00000000ffff)
  }

  if m0 {
    // >0x0    use   msdos-driver    
    off = pageOff + 0
    // uh oh unhandled kind

  }
  // 0x0    uquadle    1600000000ffff    
  off = pageOff + 0
  {
    iv, ok := readUint64be(tb, off)
    m0 = ok && (uint64(iv) == 0x1600000000ffff)
  }

  if m0 {
    // >0x0    use   msdos-driver    
    off = pageOff + 0
    // uh oh unhandled kind

  }
  // 0x0    uquadle    bf708c2ffffffff    
  off = pageOff + 0
  {
    iv, ok := readUint64be(tb, off)
    m0 = ok && (uint64(iv) == 0xbf708c2ffffffff)
  }

  if m0 {
    // >0x0    use   msdos-driver    
    off = pageOff + 0
    // uh oh unhandled kind

  }
  // 0x0    uquadle    7bd08c2ffffffff    
  off = pageOff + 0
  {
    iv, ok := readUint64be(tb, off)
    m0 = ok && (uint64(iv) == 0x7bd08c2ffffffff)
  }

  if m0 {
    // >0x0    use   msdos-driver    
    off = pageOff + 0
    // uh oh unhandled kind

  }
  // 0x0    ubytele    8c    
  off = pageOff + 0
  {
    iv, ok := readUint8be(tb, off)
    m0 = ok && (uint64(iv) == 0x8c)
  }

  if m0 {
    // >0x4    string    "O===="    
    off = pageOff + 4
    // uh oh unhandled kind

    if m1 {
      // >>0x5    string    "MAIN"    
      off = pageOff + 5
      // uh oh unhandled kind

      if m2 {
        // >>>0x4    ubytele    d    DOS executable (COM, 0x8C-variant)
        off = pageOff + 4
        {
          iv, ok := readUint8be(tb, off)
          m3 = ok && (int64(int8(iv)) > 0xd)
        }
        if m3 {
          out = append(out, "DOS executable (COM, 0x8C-variant)")
        }

      }
    }
  }
  // 0x0    ulongle    ffff10eb    DR-DOS executable (COM)
  off = pageOff + 0
  {
    iv, ok := readUint32be(tb, off)
    m0 = ok && (uint64(iv) == 0xffff10eb)
  }
  if m0 {
    out = append(out, "DR-DOS executable (COM)")
  }

  // 0x0    ushortbe    eb00&0xeb8d    
  off = pageOff + 0
  {
    iv, ok := readUint16le(tb, off)
    m0 = ok && (int64(int16(iv)) > 0xeb00)
  }

  // 0x0    bytele    eb    
  off = pageOff + 0
  {
    iv, ok := readUint8be(tb, off)
    m0 = ok && (uint64(iv) == 0xeb)
  }

  if m0 {
    // >0x1    bytele    -1    
    off = pageOff + 1
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (int64(int8(iv)) > -1)
    }

    if m1 {
      // >>(0x1.bytele+2)    bytele    0    
      // uh oh indirect offset
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }

      if m2 {
        // >>>0x0    use   msdos-com    
        off = pageOff + 0
        // uh oh unhandled kind

      }
    }
  }
  // 0x0    bytele    e9    
  off = pageOff + 0
  {
    iv, ok := readUint8be(tb, off)
    m0 = ok && (uint64(iv) == 0xe9)
  }

  if m0 {
    // >0x1    shortle    -1    
    off = pageOff + 1
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (int64(int16(iv)) > -1)
    }

    if m1 {
      // >>(0x1.shortle+3)    bytele    0    
      // uh oh indirect offset
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }

      if m2 {
        // >>>0x0    use   msdos-com    
        off = pageOff + 0
        // uh oh unhandled kind

      }
    }
    // >0x1    shortle    -103    
    off = pageOff + 1
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (int64(int16(iv)) < -259)
    }

    if m1 {
      // >>(0x1.shortle+65539)    bytele    0    
      // uh oh indirect offset
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }

      if m2 {
        // >>>0x0    use   msdos-com    
        off = pageOff + 0
        // uh oh unhandled kind

      }
    }
  }
  // 0x0    ubytele    b8    
  off = pageOff + 0
  {
    iv, ok := readUint8be(tb, off)
    m0 = ok && (uint64(iv) == 0xb8)
  }

  if m0 {
    // >0x0    string    "\xb8\xc0\a\x8e"    
    off = pageOff + 0
    // uh oh unhandled kind

    if m1 {
      // >>0x1    longle    21cd4cfe&0xfffffffe    COM executable (32-bit COMBOOT
      off = pageOff + 1
      {
        iv, ok := readUint32be(tb, off)
        m2 = ok && (uint64(iv) == 0x21cd4cfe)
      }
      if m2 {
        out = append(out, "COM executable (32-bit COMBOOT")
      }

      if m2 {
        // >>>0x1    longle    21cd4cff    \b)
        off = pageOff + 1
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x21cd4cff)
        }
        if m3 {
          out = append(out, "\\b)")
        }

        // >>>0x1    longle    21cd4cfe    \b, relocatable)
        off = pageOff + 1
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x21cd4cfe)
        }
        if m3 {
          out = append(out, "\\b, relocatable)")
        }

      }
      // >>0x1    default    COM executable for DOS
      off = pageOff + 1
      // uh oh unhandled kind
      if m2 {
        out = append(out, "COM executable for DOS")
      }

    }
  }
  // 0x0    string    "\x81\xfc"    
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0x4    string    "w\x02\xcd \xb9"    
    off = pageOff + 4
    // uh oh unhandled kind

    if m1 {
      // >>0x24    string    "UPX!"    FREE-DOS executable (COM), UPX compressed
      off = pageOff + 36
      // uh oh unhandled kind
      if m2 {
        out = append(out, "FREE-DOS executable (COM), UPX compressed")
      }

    }
  }
  // 0xfc    string    "Must have DOS version"    DR-DOS executable (COM)
  off = pageOff + 252
  // uh oh unhandled kind
  if m0 {
    out = append(out, "DR-DOS executable (COM)")
  }

  // 0x22    string    "UPX!"    FREE-DOS executable (COM), UPX compressed
  off = pageOff + 34
  // uh oh unhandled kind
  if m0 {
    out = append(out, "FREE-DOS executable (COM), UPX compressed")
  }

  // 0x23    string    "UPX!"    FREE-DOS executable (COM), UPX compressed
  off = pageOff + 35
  // uh oh unhandled kind
  if m0 {
    out = append(out, "FREE-DOS executable (COM), UPX compressed")
  }

  // 0x2    string    "\xcd!"    COM executable for DOS
  off = pageOff + 2
  // uh oh unhandled kind
  if m0 {
    out = append(out, "COM executable for DOS")
  }

  // 0x4    string    "\xcd!"    COM executable for DOS
  off = pageOff + 4
  // uh oh unhandled kind
  if m0 {
    out = append(out, "COM executable for DOS")
  }

  // 0x5    string    "\xcd!"    COM executable for DOS
  off = pageOff + 5
  // uh oh unhandled kind
  if m0 {
    out = append(out, "COM executable for DOS")
  }

  // 0x7    string    "\xcd!"    
  off = pageOff + 7
  // uh oh unhandled kind

  if m0 {
    // >0x0    bytele    b8    COM executable for DOS
    off = pageOff + 0
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) != 0xb8)
    }
    if m1 {
      out = append(out, "COM executable for DOS")
    }

  }
  // 0xa    string    "\xcd!"    
  off = pageOff + 10
  // uh oh unhandled kind

  if m0 {
    // >0x5    string    "\xcd!"    COM executable for DOS
    off = pageOff + 5
    // uh oh unhandled kind
    if m1 {
      out = append(out, "COM executable for DOS")
    }

  }
  // 0xd    string    "\xcd!"    COM executable for DOS
  off = pageOff + 13
  // uh oh unhandled kind
  if m0 {
    out = append(out, "COM executable for DOS")
  }

  // 0x12    string    "\xcd!"    COM executable for MS-DOS
  off = pageOff + 18
  // uh oh unhandled kind
  if m0 {
    out = append(out, "COM executable for MS-DOS")
  }

  // 0x17    string    "\xcd!"    COM executable for MS-DOS
  off = pageOff + 23
  // uh oh unhandled kind
  if m0 {
    out = append(out, "COM executable for MS-DOS")
  }

  // 0x1e    string    "\xcd!"    COM executable for MS-DOS
  off = pageOff + 30
  // uh oh unhandled kind
  if m0 {
    out = append(out, "COM executable for MS-DOS")
  }

  // 0x46    string    "\xcd!"    COM executable for DOS
  off = pageOff + 70
  // uh oh unhandled kind
  if m0 {
    out = append(out, "COM executable for DOS")
  }

  // 0x6    search/0xa    "\xfcW\xf3\xa5\xc3"    COM executable for MS-DOS
  off = pageOff + 6
  // uh oh unhandled kind
  if m0 {
    out = append(out, "COM executable for MS-DOS")
  }

  // 0x6    search/0xa    "\xfcW\xf3\xa4\xc3"    COM executable for DOS
  off = pageOff + 6
  // uh oh unhandled kind
  if m0 {
    out = append(out, "COM executable for DOS")
  }

  if m0 {
    // >0x18    search/0x10    "P\xa4\xff\xd5s"    \b, aPack compressed
    off = pageOff + 24
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, aPack compressed")
    }

  }
  // 0x3c    string    "W Collis\x00\x00"    COM executable for MS-DOS, Compack compressed
  off = pageOff + 60
  // uh oh unhandled kind
  if m0 {
    out = append(out, "COM executable for MS-DOS, Compack compressed")
  }

  // 0x0    string    "LZ"    MS-DOS executable (built-in)
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "MS-DOS executable (built-in)")
  }

  // 0x0    string    "\xd0\xcf\x11\u0871\x1a\xe1AAFB\r\x00OM\x06\x0e+4\x01\x01\x01\xff"    AAF legacy file using MS Structured Storage
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "AAF legacy file using MS Structured Storage")
  }

  if m0 {
    // >0x1e    bytele    9    (512B sectors)
    off = pageOff + 30
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) == 0x9)
    }
    if m1 {
      out = append(out, "(512B sectors)")
    }

    // >0x1e    bytele    c    (4kB sectors)
    off = pageOff + 30
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) == 0xc)
    }
    if m1 {
      out = append(out, "(4kB sectors)")
    }

  }
  // 0x0    string    "\xd0\xcf\x11\u0871\x1a\xe1\x01\x02\x01\r\x00\x02\x00\x00\x06\x0e+4\x03\x02\x01\x01"    AAF file using MS Structured Storage
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "AAF file using MS Structured Storage")
  }

  if m0 {
    // >0x1e    bytele    9    (512B sectors)
    off = pageOff + 30
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) == 0x9)
    }
    if m1 {
      out = append(out, "(512B sectors)")
    }

    // >0x1e    bytele    c    (4kB sectors)
    off = pageOff + 30
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) == 0xc)
    }
    if m1 {
      out = append(out, "(4kB sectors)")
    }

  }
  // 0x820    string    "Microsoft Word 6.0 Document"    %s
  off = pageOff + 2080
  // uh oh unhandled kind
  if m0 {
    out = append(out, "%s")
  }

  // 0x820    string    "Documento Microsoft Word 6"    Spanish Microsoft Word 6 document data
  off = pageOff + 2080
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Spanish Microsoft Word 6 document data")
  }

  // 0x840    string    "MSWordDoc"    Microsoft Word document data
  off = pageOff + 2112
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Microsoft Word document data")
  }

  // 0x0    longbe    31be0000    Microsoft Word Document
  off = pageOff + 0
  {
    iv, ok := readUint32le(tb, off)
    m0 = ok && (uint64(iv) == 0x31be0000)
  }
  if m0 {
    out = append(out, "Microsoft Word Document")
  }

  // 0x0    string    "PO^Q`"    Microsoft Word 6.0 Document
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Microsoft Word 6.0 Document")
  }

  // 0x4    longle    0    
  off = pageOff + 4
  {
    iv, ok := readUint32be(tb, off)
    m0 = ok && (uint64(iv) == 0x0)
  }

  if m0 {
    // >0x0    longbe    fe320000    Microsoft Word for Macintosh 1.0
    off = pageOff + 0
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) == 0xfe320000)
    }
    if m1 {
      out = append(out, "Microsoft Word for Macintosh 1.0")
    }

    // >0x0    longbe    fe340000    Microsoft Word for Macintosh 3.0
    off = pageOff + 0
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) == 0xfe340000)
    }
    if m1 {
      out = append(out, "Microsoft Word for Macintosh 3.0")
    }

    // >0x0    longbe    fe37001c    Microsoft Word for Macintosh 4.0
    off = pageOff + 0
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) == 0xfe37001c)
    }
    if m1 {
      out = append(out, "Microsoft Word for Macintosh 4.0")
    }

    // >0x0    longbe    fe370023    Microsoft Word for Macintosh 5.0
    off = pageOff + 0
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) == 0xfe370023)
    }
    if m1 {
      out = append(out, "Microsoft Word for Macintosh 5.0")
    }

  }
  // 0x0    string    "-\x00\x00\x00"    Microsoft Word 2.0 Document
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Microsoft Word 2.0 Document")
  }

  // 0x200    string    "\xec\xa5\xc1"    Microsoft Word Document
  off = pageOff + 512
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Microsoft Word Document")
  }

  // 0x0    string    "-\x00"    Microsoft WinWord 2.0 Document
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Microsoft WinWord 2.0 Document")
  }

  // 0x820    string    "Microsoft Excel 5.0 Worksheet"    %s
  off = pageOff + 2080
  // uh oh unhandled kind
  if m0 {
    out = append(out, "%s")
  }

  // 0x0    string    "-\x00"    Microsoft WinWord 2.0 Document
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Microsoft WinWord 2.0 Document")
  }

  // 0x820    string    "Foglio di lavoro Microsoft Exce"    %s
  off = pageOff + 2080
  // uh oh unhandled kind
  if m0 {
    out = append(out, "%s")
  }

  // 0x842    string    "Biff5"    Microsoft Excel 5.0 Worksheet
  off = pageOff + 2114
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Microsoft Excel 5.0 Worksheet")
  }

  // 0x849    string    "Biff5"    Microsoft Excel 5.0 Worksheet
  off = pageOff + 2121
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Microsoft Excel 5.0 Worksheet")
  }

  // 0x0    string    "\t\x04\x06\x00\x00\x00\x10\x00"    Microsoft Excel Worksheet
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Microsoft Excel Worksheet")
  }

  // 0x0    longbe    1a00    
  off = pageOff + 0
  {
    iv, ok := readUint32le(tb, off)
    m0 = ok && (uint64(iv) == 0x1a00)
  }

  if m0 {
    // >0x14    ubytele    0    
    off = pageOff + 20
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (int64(int8(iv)) > 0x0)
    }

    if m1 {
      // >>0x14    ubytele    20    Lotus 1-2-3
      off = pageOff + 20
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (int64(int8(iv)) < 0x20)
      }
      if m2 {
        out = append(out, "Lotus 1-2-3")
      }

      if m2 {
        // >>>0x4    ushortle    1000    WorKsheet, version 3
        off = pageOff + 4
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x1000)
        }
        if m3 {
          out = append(out, "WorKsheet, version 3")
        }

        // >>>0x4    ushortle    1002    WorKsheet, version 4
        off = pageOff + 4
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x1002)
        }
        if m3 {
          out = append(out, "WorKsheet, version 4")
        }

        // >>>0x4    ushortle    1003    WorKsheet, version 97
        off = pageOff + 4
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x1003)
        }
        if m3 {
          out = append(out, "WorKsheet, version 97")
        }

        // >>>0x4    ushortle    1005    WorKsheet, version 9.8 Millennium
        off = pageOff + 4
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x1005)
        }
        if m3 {
          out = append(out, "WorKsheet, version 9.8 Millennium")
        }

        // >>>0x4    ushortle    8001    FoRMatting data
        off = pageOff + 4
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x8001)
        }
        if m3 {
          out = append(out, "FoRMatting data")
        }

        // >>>0x4    ushortle    8007    ForMatting data, version 3
        off = pageOff + 4
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x8007)
        }
        if m3 {
          out = append(out, "ForMatting data, version 3")
        }

        // >>>0x4    default    unknown
        off = pageOff + 4
        // uh oh unhandled kind
        if m3 {
          out = append(out, "unknown")
        }

        if m3 {
          // >>>>0x6    ushortle    4    worksheet
          off = pageOff + 6
          {
            iv, ok := readUint16be(tb, off)
            m4 = ok && (uint64(iv) == 0x4)
          }
          if m4 {
            out = append(out, "worksheet")
          }

          // >>>>0x6    ushortle    4    formatting data
          off = pageOff + 6
          {
            iv, ok := readUint16be(tb, off)
            m4 = ok && (uint64(iv) != 0x4)
          }
          if m4 {
            out = append(out, "formatting data")
          }

          // >>>>0x4    ushortle    0    \b, revision 0x%x
          off = pageOff + 4
          {
            iv, ok := readUint16be(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }
          if m4 {
            out = append(out, "\\b, revision 0x%x")
          }

        }
        // >>>0x6    ushortle    4    \b, cell range
        off = pageOff + 6
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x4)
        }
        if m3 {
          out = append(out, "\\b, cell range")
        }

        if m3 {
          // >>>>0x8    ulongle    0    
          off = pageOff + 8
          {
            iv, ok := readUint32be(tb, off)
            m4 = ok && (uint64(iv) != 0x0)
          }

          if m4 {
            // >>>>>0xa    ubytele    0    \b%d*
            off = pageOff + 10
            {
              iv, ok := readUint8be(tb, off)
              m5 = ok && (int64(int8(iv)) > 0x0)
            }
            if m5 {
              out = append(out, "\\b%d*")
            }

            // >>>>>0x8    ushortle    0    \b%d,
            off = pageOff + 8
            {
              iv, ok := readUint16be(tb, off)
              m5 = ok && (uint64(iv) == 0x0)
            }
            if m5 {
              out = append(out, "\\b%d,")
            }

            // >>>>>0xb    ubytele    0    \b%d-
            off = pageOff + 11
            {
              iv, ok := readUint8be(tb, off)
              m5 = ok && (uint64(iv) == 0x0)
            }
            if m5 {
              out = append(out, "\\b%d-")
            }

          }
          // >>>>0xe    ubytele    0    \b%d*
          off = pageOff + 14
          {
            iv, ok := readUint8be(tb, off)
            m4 = ok && (int64(int8(iv)) > 0x0)
          }
          if m4 {
            out = append(out, "\\b%d*")
          }

          // >>>>0xc    ushortle    0    \b%d,
          off = pageOff + 12
          {
            iv, ok := readUint16be(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }
          if m4 {
            out = append(out, "\\b%d,")
          }

          // >>>>0xf    ubytele    0    \b%d
          off = pageOff + 15
          {
            iv, ok := readUint8be(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }
          if m4 {
            out = append(out, "\\b%d")
          }

          // >>>>0x14    ubytele    1    \b, character set 0x%x
          off = pageOff + 20
          {
            iv, ok := readUint8be(tb, off)
            m4 = ok && (int64(int8(iv)) > 0x1)
          }
          if m4 {
            out = append(out, "\\b, character set 0x%x")
          }

          // >>>>0x15    ubytele    0    \b, flags 0x%x
          off = pageOff + 21
          {
            iv, ok := readUint8be(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }
          if m4 {
            out = append(out, "\\b, flags 0x%x")
          }

        }
        // >>>0x6    ushortle    4    
        off = pageOff + 6
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) != 0x4)
        }

        if m3 {
          // >>>>0x1e    search/0x1d    "\x00\xae"    
          off = pageOff + 30
          // uh oh unhandled kind

          if m4 {
            // >>>>>&0x4    string    ">\x00"    \b, 1st font "%s"
            off = pageOff + 4
            // uh oh unhandled kind
            if m5 {
              out = append(out, "\\b, 1st font \"%s\"")
            }

          }
        }
      }
    }
  }
  // 0x0    longbe    200    
  off = pageOff + 0
  {
    iv, ok := readUint32le(tb, off)
    m0 = ok && (uint64(iv) == 0x200)
  }

  if m0 {
    // >0x7    ubytele    0    
    off = pageOff + 7
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }

    if m1 {
      // >>0x6    ubytele    0    Lotus
      off = pageOff + 6
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (int64(int8(iv)) > 0x0)
      }
      if m2 {
        out = append(out, "Lotus")
      }

      if m2 {
        // >>>0x4    ushortle    7    1-2-3 CoNFiguration, version 2.x (PGRAPH.CNF)
        off = pageOff + 4
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x7)
        }
        if m3 {
          out = append(out, "1-2-3 CoNFiguration, version 2.x (PGRAPH.CNF)")
        }

        // >>>0x4    ushortle    c05    1-2-3 CoNFiguration, version 2.4J
        off = pageOff + 4
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0xc05)
        }
        if m3 {
          out = append(out, "1-2-3 CoNFiguration, version 2.4J")
        }

        // >>>0x4    ushortle    801    1-2-3 CoNFiguration, version 1-2.1
        off = pageOff + 4
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x801)
        }
        if m3 {
          out = append(out, "1-2-3 CoNFiguration, version 1-2.1")
        }

        // >>>0x4    ushortle    802    Symphony CoNFiguration
        off = pageOff + 4
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x802)
        }
        if m3 {
          out = append(out, "Symphony CoNFiguration")
        }

        // >>>0x4    ushortle    804    1-2-3 CoNFiguration, version 2.2
        off = pageOff + 4
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x804)
        }
        if m3 {
          out = append(out, "1-2-3 CoNFiguration, version 2.2")
        }

        // >>>0x4    ushortle    80a    1-2-3 CoNFiguration, version 2.3-2.4
        off = pageOff + 4
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x80a)
        }
        if m3 {
          out = append(out, "1-2-3 CoNFiguration, version 2.3-2.4")
        }

        // >>>0x4    ushortle    1402    1-2-3 CoNFiguration, version 3.x
        off = pageOff + 4
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x1402)
        }
        if m3 {
          out = append(out, "1-2-3 CoNFiguration, version 3.x")
        }

        // >>>0x4    ushortle    1450    1-2-3 CoNFiguration, version 4.x
        off = pageOff + 4
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x1450)
        }
        if m3 {
          out = append(out, "1-2-3 CoNFiguration, version 4.x")
        }

        // >>>0x4    ushortle    404    1-2-3 WorKSheet, version 1
        off = pageOff + 4
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x404)
        }
        if m3 {
          out = append(out, "1-2-3 WorKSheet, version 1")
        }

        // >>>0x4    ushortle    405    Symphony WoRksheet, version 1.0
        off = pageOff + 4
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x405)
        }
        if m3 {
          out = append(out, "Symphony WoRksheet, version 1.0")
        }

        // >>>0x4    ushortle    406    1-2-3/Symphony worksheet, version 2
        off = pageOff + 4
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x406)
        }
        if m3 {
          out = append(out, "1-2-3/Symphony worksheet, version 2")
        }

        // >>>0x4    ushortle    600    1-2-3 WorKsheet, version 1.xJ
        off = pageOff + 4
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x600)
        }
        if m3 {
          out = append(out, "1-2-3 WorKsheet, version 1.xJ")
        }

        // >>>0x4    ushortle    602    1-2-3 worksheet, version 2.4J
        off = pageOff + 4
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x602)
        }
        if m3 {
          out = append(out, "1-2-3 worksheet, version 2.4J")
        }

        // >>>0x4    ushortle    8006    1-2-3 ForMaTting data, version 2.x
        off = pageOff + 4
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x8006)
        }
        if m3 {
          out = append(out, "1-2-3 ForMaTting data, version 2.x")
        }

        // >>>0x4    ushortle    8007    1-2-3 FoRMatting data, version 2.0
        off = pageOff + 4
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x8007)
        }
        if m3 {
          out = append(out, "1-2-3 FoRMatting data, version 2.0")
        }

        // >>>0x4    default    unknown worksheet or configuration
        off = pageOff + 4
        // uh oh unhandled kind
        if m3 {
          out = append(out, "unknown worksheet or configuration")
        }

        if m3 {
          // >>>>0x4    ushortle    0    \b, revision 0x%x
          off = pageOff + 4
          {
            iv, ok := readUint16be(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }
          if m4 {
            out = append(out, "\\b, revision 0x%x")
          }

        }
        // >>>0x6    use   lotus-cells    
        off = pageOff + 6
        // uh oh unhandled kind

        // >>>(0x8.shortle+10)    use   lotus-cells    
        // uh oh indirect offset
        // uh oh unhandled kind

      }
    }
  }
  // 0x0    string    "WordPro\x00"    Lotus WordPro
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Lotus WordPro")
  }

  // 0x0    string    "WordPro\r\xfb"    Lotus WordPro
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Lotus WordPro")
  }

  // 0x0    string    "q\xa8\x00\x00\x01\x02"    
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0xc    string    "Stirling Technologies,"    InstallShield Uninstall Script
    off = pageOff + 12
    // uh oh unhandled kind
    if m1 {
      out = append(out, "InstallShield Uninstall Script")
    }

  }
  // 0x0    string    "Nullsoft AVS Preset "    Winamp plug in
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Winamp plug in")
  }

  // 0x0    string    "\xd7\xcd"    ms-windows metafont .wmf
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "ms-windows metafont .wmf")
  }

  // 0x0    string    "\x02\x00\t\x00"    ms-windows metafont .wmf
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "ms-windows metafont .wmf")
  }

  // 0x0    string    "\x01\x00\t\x00"    ms-windows metafont .wmf
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "ms-windows metafont .wmf")
  }

  // 0x0    string    "\x03\x01\x01\x048\x01\x00\x00"    tz3 ms-works file
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "tz3 ms-works file")
  }

  // 0x0    string    "\x03\x02\x01\x048\x01\x00\x00"    tz3 ms-works file
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "tz3 ms-works file")
  }

  // 0x0    string    "\x03\x03\x01\x048\x01\x00\x00"    tz3 ms-works file
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "tz3 ms-works file")
  }

  // 0x0    string    "\x89\x00?\x03\x05\x003\x9fW5\x17\xb6i4\x05%A\x9b\x11\x02"    PGP sig
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "PGP sig")
  }

  // 0x0    string    "\x89\x00?\x03\x05\x003\x9fW6\x17\xb6i4\x05%A\x9b\x11\x02"    PGP sig
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "PGP sig")
  }

  // 0x0    string    "\x89\x00?\x03\x05\x003\x9fW7\x17\xb6i4\x05%A\x9b\x11\x02"    PGP sig
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "PGP sig")
  }

  // 0x0    string    "\x89\x00?\x03\x05\x003\x9fW8\x17\xb6i4\x05%A\x9b\x11\x02"    PGP sig
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "PGP sig")
  }

  // 0x0    string    "\x89\x00?\x03\x05\x003\x9fW9\x17\xb6i4\x05%A\x9b\x11\x02"    PGP sig
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "PGP sig")
  }

  // 0x0    string    "\x89\x00\x95\x03\x05\x002R\x87\xc4@\xe5\""    PGP sig
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "PGP sig")
  }

  // 0x0    string    "MDIF\x1a\x00\b\x00\x00\x00\xfa&@}\x01\x00\x01\x1e\x01\x00"    MS Windows special zipped file
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "MS Windows special zipped file")
  }

  // 0x0    string    "BA(\x00\x00\x00.\x00\x00\x00\x00\x00\x00\x00"    Icon for MS Windows
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Icon for MS Windows")
  }

  // 0x0    longbe    100    
  off = pageOff + 0
  {
    iv, ok := readUint32le(tb, off)
    m0 = ok && (uint64(iv) == 0x100)
  }

  if m0 {
    // >0x9    bytele    0    
    off = pageOff + 9
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }

    if m1 {
      // >>0x0    bytele    0    
      off = pageOff + 0
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }

      // >>0x0    use   cur-ico-dir    
      off = pageOff + 0
      // uh oh unhandled kind

    }
    // >0x9    ubytele    ff    
    off = pageOff + 9
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) == 0xff)
    }

    if m1 {
      // >>0x0    bytele    0    
      off = pageOff + 0
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }

      // >>0x0    use   cur-ico-dir    
      off = pageOff + 0
      // uh oh unhandled kind

    }
  }
  // 0x0    longbe    200    
  off = pageOff + 0
  {
    iv, ok := readUint32le(tb, off)
    m0 = ok && (uint64(iv) == 0x200)
  }

  if m0 {
    // >0x9    bytele    0    
    off = pageOff + 9
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }

    if m1 {
      // >>0x0    use   cur-ico-dir    
      off = pageOff + 0
      // uh oh unhandled kind

    }
    // >0x9    ubytele    ff    
    off = pageOff + 9
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) == 0xff)
    }

    if m1 {
      // >>0x0    use   cur-ico-dir    
      off = pageOff + 0
      // uh oh unhandled kind

    }
  }
  // 0x0    string    "PK\b\bBGI"    Borland font
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Borland font")
  }

  if m0 {
    // >0x4    string    ">\x00"    %s
    off = pageOff + 4
    // uh oh unhandled kind
    if m1 {
      out = append(out, "%s")
    }

  }
  // 0x0    string    "pk\b\bBGI"    Borland device
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Borland device")
  }

  if m0 {
    // >0x4    string    ">\x00"    %s
    off = pageOff + 4
    // uh oh unhandled kind
    if m1 {
      out = append(out, "%s")
    }

  }
  // 0x0    longle    4    
  off = pageOff + 0
  {
    iv, ok := readUint32be(tb, off)
    m0 = ok && (uint64(iv) == 0x4)
  }

  if m0 {
    // >0xc    longle    118    Windows Recycle Bin INFO2 file (Win98 or below)
    off = pageOff + 12
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) == 0x118)
    }
    if m1 {
      out = append(out, "Windows Recycle Bin INFO2 file (Win98 or below)")
    }

  }
  // 0x0    longle    5    
  off = pageOff + 0
  {
    iv, ok := readUint32be(tb, off)
    m0 = ok && (uint64(iv) == 0x5)
  }

  if m0 {
    // >0xc    longle    320    Windows Recycle Bin INFO2 file (Win2k - WinXP)
    off = pageOff + 12
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) == 0x320)
    }
    if m1 {
      out = append(out, "Windows Recycle Bin INFO2 file (Win2k - WinXP)")
    }

  }
  // 0x9    string    "GERBILDOC"    First Choice document
  off = pageOff + 9
  // uh oh unhandled kind
  if m0 {
    out = append(out, "First Choice document")
  }

  // 0x9    string    "GERBILDB"    First Choice database
  off = pageOff + 9
  // uh oh unhandled kind
  if m0 {
    out = append(out, "First Choice database")
  }

  // 0x9    string    "GERBILCLIP"    First Choice database
  off = pageOff + 9
  // uh oh unhandled kind
  if m0 {
    out = append(out, "First Choice database")
  }

  // 0x0    string    "GERBIL"    First Choice device file
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "First Choice device file")
  }

  // 0x9    string    "RABBITGRAPH"    RabbitGraph file
  off = pageOff + 9
  // uh oh unhandled kind
  if m0 {
    out = append(out, "RabbitGraph file")
  }

  // 0x0    string    "DCU1"    Borland Delphi .DCU file
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Borland Delphi .DCU file")
  }

  // 0x0    string    "=!<spell>"    MKS Spell hash list (old format)
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "MKS Spell hash list (old format)")
  }

  // 0x0    string    "=!<spell2>"    MKS Spell hash list
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "MKS Spell hash list")
  }

  // 0x0    longle    8086b70    TurboC BGI file
  off = pageOff + 0
  {
    iv, ok := readUint32be(tb, off)
    m0 = ok && (uint64(iv) == 0x8086b70)
  }
  if m0 {
    out = append(out, "TurboC BGI file")
  }

  // 0x0    longle    8084b50    TurboC Font file
  off = pageOff + 0
  {
    iv, ok := readUint32be(tb, off)
    m0 = ok && (uint64(iv) == 0x8084b50)
  }
  if m0 {
    out = append(out, "TurboC Font file")
  }

  // 0x0    string    "TPF0"    
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "PMCC"    Windows 3.x .GRP file
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Windows 3.x .GRP file")
  }

  // 0x1    string    "RDC-meg"    MegaDots
  off = pageOff + 1
  // uh oh unhandled kind
  if m0 {
    out = append(out, "MegaDots")
  }

  if m0 {
    // >0x8    bytele    2f    version %c
    off = pageOff + 8
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (int64(int8(iv)) > 0x2f)
    }
    if m1 {
      out = append(out, "version %c")
    }

    // >0x9    bytele    2f    \b.%c file
    off = pageOff + 9
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (int64(int8(iv)) > 0x2f)
    }
    if m1 {
      out = append(out, "\\b.%c file")
    }

  }
  // 0x0    longle    4c    
  off = pageOff + 0
  {
    iv, ok := readUint32be(tb, off)
    m0 = ok && (uint64(iv) == 0x4c)
  }

  if m0 {
    // >0x4    longle    21401    Windows shortcut file
    off = pageOff + 4
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) == 0x21401)
    }
    if m1 {
      out = append(out, "Windows shortcut file")
    }

  }
  // 0x171    string    "MICROSOFT PIFEX\x00"    Windows Program Information File
  off = pageOff + 369
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Windows Program Information File")
  }

  if m0 {
    // >0x24    string    ">\x00"    \b for %.63s
    off = pageOff + 36
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b for %.63s")
    }

    // >0x65    string    ">\x00"    \b, directory=%.64s
    off = pageOff + 101
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, directory=%.64s")
    }

    // >0xa5    string    ">\x00"    \b, parameters=%.64s
    off = pageOff + 165
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, parameters=%.64s")
    }

    // >0x187    search/0xb55    "WINDOWS VMM 4.0\x00"    
    off = pageOff + 391
    // uh oh unhandled kind

    if m1 {
      // >>&0x5e    ubytele    0    
      off = pageOff + 94
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (int64(int8(iv)) > 0x0)
      }

      if m2 {
        // >>>&0x-1    string    "<PIFMGR.DLL"    \b, icon=%s
        off = pageOff + -1
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, icon=%s")
        }

        // >>>&0x-1    string    ">PIFMGR.DLL"    \b, icon=%s
        off = pageOff + -1
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, icon=%s")
        }

      }
      // >>&0xf0    ubytele    0    
      off = pageOff + 240
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (int64(int8(iv)) > 0x0)
      }

      if m2 {
        // >>>&0x-1    string    "<Terminal"    \b, font=%.32s
        off = pageOff + -1
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, font=%.32s")
        }

        // >>>&0x-1    string    ">Terminal"    \b, font=%.32s
        off = pageOff + -1
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, font=%.32s")
        }

      }
      // >>&0x110    ubytele    0    
      off = pageOff + 272
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (int64(int8(iv)) > 0x0)
      }

      if m2 {
        // >>>&0x-1    string    "<Lucida Console"    \b, TrueTypeFont=%.32s
        off = pageOff + -1
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, TrueTypeFont=%.32s")
        }

        // >>>&0x-1    string    ">Lucida Console"    \b, TrueTypeFont=%.32s
        off = pageOff + -1
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, TrueTypeFont=%.32s")
        }

      }
    }
    // >0x187    search/0xb55    "WINDOWS NT  3.1\x00"    \b, Windows NT-style
    off = pageOff + 391
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, Windows NT-style")
    }

    // >0x187    search/0xb55    "CONFIG  SYS 4.0\x00"    \b +CONFIG.SYS
    off = pageOff + 391
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b +CONFIG.SYS")
    }

    // >0x187    search/0xb55    "AUTOEXECBAT 4.0\x00"    \b +AUTOEXEC.BAT
    off = pageOff + 391
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b +AUTOEXEC.BAT")
    }

  }
  // 0x0    longbe    c5d0d3c6    DOS EPS Binary File
  off = pageOff + 0
  {
    iv, ok := readUint32le(tb, off)
    m0 = ok && (uint64(iv) == 0xc5d0d3c6)
  }
  if m0 {
    out = append(out, "DOS EPS Binary File")
  }

  if m0 {
    // >0x4    longle    0    Postscript starts at byte %d
    off = pageOff + 4
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (int64(int32(iv)) > 0x0)
    }
    if m1 {
      out = append(out, "Postscript starts at byte %d")
    }

    if m1 {
      // >>0x8    longle    0    length %d
      off = pageOff + 8
      {
        iv, ok := readUint32be(tb, off)
        m2 = ok && (int64(int32(iv)) > 0x0)
      }
      if m2 {
        out = append(out, "length %d")
      }

      if m2 {
        // >>>0xc    longle    0    Metafile starts at byte %d
        off = pageOff + 12
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (int64(int32(iv)) > 0x0)
        }
        if m3 {
          out = append(out, "Metafile starts at byte %d")
        }

        if m3 {
          // >>>>0x10    longle    0    length %d
          off = pageOff + 16
          {
            iv, ok := readUint32be(tb, off)
            m4 = ok && (int64(int32(iv)) > 0x0)
          }
          if m4 {
            out = append(out, "length %d")
          }

        }
        // >>>0x14    longle    0    TIFF starts at byte %d
        off = pageOff + 20
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (int64(int32(iv)) > 0x0)
        }
        if m3 {
          out = append(out, "TIFF starts at byte %d")
        }

        if m3 {
          // >>>>0x18    longle    0    length %d
          off = pageOff + 24
          {
            iv, ok := readUint32be(tb, off)
            m4 = ok && (int64(int32(iv)) > 0x0)
          }
          if m4 {
            out = append(out, "length %d")
          }

        }
      }
    }
  }
  // 0x0    shortle    223e9f78    TNEF
  off = pageOff + 0
  {
    iv, ok := readUint16be(tb, off)
    m0 = ok && (uint64(iv) == 0x223e9f78)
  }
  if m0 {
    out = append(out, "TNEF")
  }

  // 0x0    string    "NG\x00\x01"    
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0x2    ulongle    100    Norton Guide
    off = pageOff + 2
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) == 0x100)
    }
    if m1 {
      out = append(out, "Norton Guide")
    }

    if m1 {
      // >>0x8    string    ">\x00"    "%-.40s"
      off = pageOff + 8
      // uh oh unhandled kind
      if m2 {
        out = append(out, "\"%-.40s\"")
      }

      // >>0x30    string    ">\x00"    \b, %-.66s
      off = pageOff + 48
      // uh oh unhandled kind
      if m2 {
        out = append(out, "\\b, %-.66s")
      }

      // >>0x72    string    ">\x00"    %-.66s
      off = pageOff + 114
      // uh oh unhandled kind
      if m2 {
        out = append(out, "%-.66s")
      }

    }
  }
  // 0x0    ulongle    48443408    4DOS help file
  off = pageOff + 0
  {
    iv, ok := readUint32be(tb, off)
    m0 = ok && (uint64(iv) == 0x48443408)
  }
  if m0 {
    out = append(out, "4DOS help file")
  }

  if m0 {
    // >0x4    string    "x"    \b, version %-4.4s
    off = pageOff + 4
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, version %-4.4s")
    }

  }
  // 0x0    uquadle    3a000000024e4c    MS Advisor help file
  off = pageOff + 0
  {
    iv, ok := readUint64be(tb, off)
    m0 = ok && (uint64(iv) == 0x3a000000024e4c)
  }
  if m0 {
    out = append(out, "MS Advisor help file")
  }

  // 0x0    string    "ITSF\x03\x00\x00\x00`\x00\x00\x00"    MS Windows HtmlHelp Data
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "MS Windows HtmlHelp Data")
  }

  // 0x2    string    "GFA-BASIC3"    GFA-BASIC 3 data
  off = pageOff + 2
  // uh oh unhandled kind
  if m0 {
    out = append(out, "GFA-BASIC 3 data")
  }

  // 0x0    string    "MSCF\x00\x00\x00\x00"    Microsoft Cabinet archive data
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Microsoft Cabinet archive data")
  }

  if m0 {
    // >0x8    longle    0    \b, %u bytes
    off = pageOff + 8
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      out = append(out, "\\b, %u bytes")
    }

    // >0x1c    shortle    1    \b, 1 file
    off = pageOff + 28
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x1)
    }
    if m1 {
      out = append(out, "\\b, 1 file")
    }

    // >0x1c    shortle    1    \b, %u files
    off = pageOff + 28
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (int64(int16(iv)) > 0x1)
    }
    if m1 {
      out = append(out, "\\b, %u files")
    }

  }
  // 0x0    string    "ISc("    InstallShield Cabinet archive data
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "InstallShield Cabinet archive data")
  }

  if m0 {
    // >0x5    bytele    60&0xf0    version 6,
    off = pageOff + 5
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) == 0x60)
    }
    if m1 {
      out = append(out, "version 6,")
    }

    // >0x5    bytele    60&0xf0    version 4/5,
    off = pageOff + 5
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) != 0x60)
    }
    if m1 {
      out = append(out, "version 4/5,")
    }

    // >(0xc.longle+40)    longle    0    %u files
    // uh oh indirect offset
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      out = append(out, "%u files")
    }

  }
  // 0x0    string    "MSCE\x00\x00\x00\x00"    Microsoft WinCE install header
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Microsoft WinCE install header")
  }

  if m0 {
    // >0x14    longle    0    \b, architecture-independent
    off = pageOff + 20
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      out = append(out, "\\b, architecture-independent")
    }

    // >0x14    longle    67    \b, Hitachi SH3
    off = pageOff + 20
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) == 0x67)
    }
    if m1 {
      out = append(out, "\\b, Hitachi SH3")
    }

    // >0x14    longle    68    \b, Hitachi SH4
    off = pageOff + 20
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) == 0x68)
    }
    if m1 {
      out = append(out, "\\b, Hitachi SH4")
    }

    // >0x14    longle    a11    \b, StrongARM
    off = pageOff + 20
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) == 0xa11)
    }
    if m1 {
      out = append(out, "\\b, StrongARM")
    }

    // >0x14    longle    fa0    \b, MIPS R4000
    off = pageOff + 20
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) == 0xfa0)
    }
    if m1 {
      out = append(out, "\\b, MIPS R4000")
    }

    // >0x14    longle    2713    \b, Hitachi SH3
    off = pageOff + 20
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) == 0x2713)
    }
    if m1 {
      out = append(out, "\\b, Hitachi SH3")
    }

    // >0x14    longle    2714    \b, Hitachi SH3E
    off = pageOff + 20
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) == 0x2714)
    }
    if m1 {
      out = append(out, "\\b, Hitachi SH3E")
    }

    // >0x14    longle    2715    \b, Hitachi SH4
    off = pageOff + 20
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) == 0x2715)
    }
    if m1 {
      out = append(out, "\\b, Hitachi SH4")
    }

    // >0x14    longle    11171    \b, ARM 7TDMI
    off = pageOff + 20
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) == 0x11171)
    }
    if m1 {
      out = append(out, "\\b, ARM 7TDMI")
    }

    // >0x34    shortle    1    \b, 1 file
    off = pageOff + 52
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x1)
    }
    if m1 {
      out = append(out, "\\b, 1 file")
    }

    // >0x34    shortle    1    \b, %u files
    off = pageOff + 52
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (int64(int16(iv)) > 0x1)
    }
    if m1 {
      out = append(out, "\\b, %u files")
    }

    // >0x38    shortle    1    \b, 1 registry entry
    off = pageOff + 56
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x1)
    }
    if m1 {
      out = append(out, "\\b, 1 registry entry")
    }

    // >0x38    shortle    1    \b, %u registry entries
    off = pageOff + 56
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (int64(int16(iv)) > 0x1)
    }
    if m1 {
      out = append(out, "\\b, %u registry entries")
    }

  }
  // 0x0    ulongle    1    
  off = pageOff + 0
  {
    iv, ok := readUint32be(tb, off)
    m0 = ok && (uint64(iv) == 0x1)
  }

  if m0 {
    // >0x28    string    " EMF"    Windows Enhanced Metafile (EMF) image data
    off = pageOff + 40
    // uh oh unhandled kind
    if m1 {
      out = append(out, "Windows Enhanced Metafile (EMF) image data")
    }

    if m1 {
      // >>0x2c    ulongle    0    version 0x%x
      off = pageOff + 44
      {
        iv, ok := readUint32be(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }
      if m2 {
        out = append(out, "version 0x%x")
      }

    }
  }
  // 0x0    string    "\xd0\xcf\x11\u0871\x1a\xe1"    Microsoft Office Document
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Microsoft Office Document")
  }

  if m0 {
    // >0x222    string    "bjbj"    Microsoft Word Document
    off = pageOff + 546
    // uh oh unhandled kind
    if m1 {
      out = append(out, "Microsoft Word Document")
    }

    // >0x222    string    "jbjb"    Microsoft Word Document
    off = pageOff + 546
    // uh oh unhandled kind
    if m1 {
      out = append(out, "Microsoft Word Document")
    }

  }
  // 0x0    string    "\x94\xa6."    Microsoft Word Document
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Microsoft Word Document")
  }

  // 0x200    string    "R\x00o\x00o\x00t\x00 \x00E\x00n\x00t\x00r\x00y"    Microsoft Word Document
  off = pageOff + 512
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Microsoft Word Document")
  }

  // 0x0    string    "$RBU"    
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0x17    string    "Dell"    %s system BIOS
    off = pageOff + 23
    // uh oh unhandled kind
    if m1 {
      out = append(out, "%s system BIOS")
    }

    // >0x5    bytele    2    
    off = pageOff + 5
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) == 0x2)
    }

    if m1 {
      // >>0x30    bytele    0    version %d.
      off = pageOff + 48
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }
      if m2 {
        out = append(out, "version %d.")
      }

      // >>0x31    bytele    0    \b%d.
      off = pageOff + 49
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }
      if m2 {
        out = append(out, "\\b%d.")
      }

      // >>0x32    bytele    0    \b%d
      off = pageOff + 50
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }
      if m2 {
        out = append(out, "\\b%d")
      }

    }
    // >0x5    bytele    2    
    off = pageOff + 5
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (int64(int8(iv)) < 0x2)
    }

    if m1 {
      // >>0x30    string    "x"    version %.3s
      off = pageOff + 48
      // uh oh unhandled kind
      if m2 {
        out = append(out, "version %.3s")
      }

    }
  }
  // 0x0    string    "DDS |\x00\x00\x00"    Microsoft DirectDraw Surface (DDS),
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Microsoft DirectDraw Surface (DDS),")
  }

  if m0 {
    // >0x10    longle    0    %d x
    off = pageOff + 16
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (int64(int32(iv)) > 0x0)
    }
    if m1 {
      out = append(out, "%d x")
    }

    // >0xc    longle    0    %d,
    off = pageOff + 12
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (int64(int32(iv)) > 0x0)
    }
    if m1 {
      out = append(out, "%d,")
    }

    // >0x54    string    "x"    %.4s
    off = pageOff + 84
    // uh oh unhandled kind
    if m1 {
      out = append(out, "%.4s")
    }

  }
  // 0x0    string    "ITOLITLS"    Microsoft Reader eBook Data
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Microsoft Reader eBook Data")
  }

  if m0 {
    // >0x8    longle    0    \b, version %u
    off = pageOff + 8
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      out = append(out, "\\b, version %u")
    }

  }
  // 0x0    string    "B000FF\n"    Windows Embedded CE binary image
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Windows Embedded CE binary image")
  }

  // 0x0    string    "MSWIM\x00\x00\x00"    Windows imaging (WIM) image
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Windows imaging (WIM) image")
  }

  // 0x0    string    "WLPWM\x00\x00\x00"    Windows imaging (WIM) image, wimlib pipable format
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Windows imaging (WIM) image, wimlib pipable format")
  }

  // 0x0    string    "\xfc\x03\x00"    Mallard BASIC program data (v1.11)
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Mallard BASIC program data (v1.11)")
  }

  // 0x0    string    "\xfc\x04\x00"    Mallard BASIC program data (v1.29+)
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Mallard BASIC program data (v1.29+)")
  }

  // 0x0    string    "\xfc\x03\x01"    Mallard BASIC protected program data (v1.11)
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Mallard BASIC protected program data (v1.11)")
  }

  // 0x0    string    "\xfc\x04\x01"    Mallard BASIC protected program data (v1.29+)
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Mallard BASIC protected program data (v1.29+)")
  }

  // 0x0    string    "MIOPEN"    Mallard BASIC Jetsam data
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Mallard BASIC Jetsam data")
  }

  // 0x0    string    "Jetsam0"    Mallard BASIC Jetsam index data
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Mallard BASIC Jetsam index data")
  }

  // 0x3    ushortle    7bb    
  off = pageOff + 3
  {
    iv, ok := readUint16be(tb, off)
    m0 = ok && (int64(int16(iv)) > 0x7bb)
  }

  if m0 {
    // >0x5    ubytele    1f    
    off = pageOff + 5
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (int64(int8(iv)) < 0x1f)
    }

    if m1 {
      // >>0x6    ubytele    c    
      off = pageOff + 6
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (int64(int8(iv)) < 0xc)
      }

      if m2 {
        // >>>0x7    string    "\x00\x00\x00\x00\x00\x00\x00\x00"    
        off = pageOff + 7
        // uh oh unhandled kind

        if m3 {
          // >>>>0x1    ubytele    0    DOS 2.0 backup id file, sequence %d
          off = pageOff + 1
          {
            iv, ok := readUint8be(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }
          if m4 {
            out = append(out, "DOS 2.0 backup id file, sequence %d")
          }

          // >>>>0x0    ubytele    ff    \b, last disk
          off = pageOff + 0
          {
            iv, ok := readUint8be(tb, off)
            m4 = ok && (uint64(iv) == 0xff)
          }
          if m4 {
            out = append(out, "\\b, last disk")
          }

        }
      }
    }
  }
  // 0x53    ubytele    50    
  off = pageOff + 83
  {
    iv, ok := readUint8be(tb, off)
    m0 = ok && (int64(int8(iv)) < 0x50)
  }

  if m0 {
    // >0x54    string    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"    
    off = pageOff + 84
    // uh oh unhandled kind

    if m1 {
      // >>0x5    string    "x"    DOS 2.0 backed up file %s,
      off = pageOff + 5
      // uh oh unhandled kind
      if m2 {
        out = append(out, "DOS 2.0 backed up file %s,")
      }

      // >>0x0    ubytele    ff    complete file
      off = pageOff + 0
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0xff)
      }
      if m2 {
        out = append(out, "complete file")
      }

      // >>0x0    ubytele    ff    
      off = pageOff + 0
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) != 0xff)
      }

      if m2 {
        // >>>0x1    ushortle    0    split file, sequence %d
        off = pageOff + 1
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x0)
        }
        if m3 {
          out = append(out, "split file, sequence %d")
        }

      }
    }
  }
  // 0x0    string    "\x8bBACKUP "    
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0xa    string    "\x00\x00\x00\x00\x00\x00\x00\x00"    
    off = pageOff + 10
    // uh oh unhandled kind

    if m1 {
      // >>0x9    ubytele    0    DOS 3.3 backup control file, sequence %d
      off = pageOff + 9
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }
      if m2 {
        out = append(out, "DOS 3.3 backup control file, sequence %d")
      }

      // >>0x8a    ubytele    ff    \b, last disk
      off = pageOff + 138
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0xff)
      }
      if m2 {
        out = append(out, "\\b, last disk")
      }

    }
  }
  return out, nil
}

func IdentifyMsdosDriver(tb []byte, pageOff int64) ([]string, error) {
  var out []string
  var off int64
  m0 := false
  m1 := false
  m2 := false
  m3 := false
  m4 := false
  m5 := false
  m6 := false

  if m0 {
    // >0x28    search/0x7    "UPX!"    \bUPX compressed
    off = pageOff + 40
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\bUPX compressed")
    }

    // >0x4    ushortle    0&0x8000    \bblock device driver
    off = pageOff + 4
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      out = append(out, "\\bblock device driver")
    }

    // >0x4    ushortle    8000&0x8000    \b
    off = pageOff + 4
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x8000)
    }
    if m1 {
      out = append(out, "\\b")
    }

    if m1 {
      // >>0x4    ushortle    8&0x8    \bclock
      off = pageOff + 4
      {
        iv, ok := readUint16be(tb, off)
        m2 = ok && (uint64(iv) == 0x8)
      }
      if m2 {
        out = append(out, "\\bclock")
      }

      // >>0x4    ushortle    10&0x10    \bfast
      off = pageOff + 4
      {
        iv, ok := readUint16be(tb, off)
        m2 = ok && (uint64(iv) == 0x10)
      }
      if m2 {
        out = append(out, "\\bfast")
      }

      // >>0x4    ushortle    0&0x3    \bstandard
      off = pageOff + 4
      {
        iv, ok := readUint16be(tb, off)
        m2 = ok && (int64(int16(iv)) > 0x0)
      }
      if m2 {
        out = append(out, "\\bstandard")
      }

      if m2 {
        // >>>0x4    ushortle    1&0x1    \binput
        off = pageOff + 4
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x1)
        }
        if m3 {
          out = append(out, "\\binput")
        }

        // >>>0x4    ushortle    3&0x3    \b/
        off = pageOff + 4
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x3)
        }
        if m3 {
          out = append(out, "\\b/")
        }

        // >>>0x4    ushortle    2&0x2    \boutput
        off = pageOff + 4
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x2)
        }
        if m3 {
          out = append(out, "\\boutput")
        }

      }
      // >>0x4    ushortle    8000&0x8000    \bcharacter device driver
      off = pageOff + 4
      {
        iv, ok := readUint16be(tb, off)
        m2 = ok && (uint64(iv) == 0x8000)
      }
      if m2 {
        out = append(out, "\\bcharacter device driver")
      }

    }
    // >0x0    ubytele    0    
    off = pageOff + 0
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }

    if m1 {
      // >>0x28    search/0x7    "UPX!"    
      off = pageOff + 40
      // uh oh unhandled kind

      // >>0x28    default    
      off = pageOff + 40
      // uh oh unhandled kind

      if m2 {
        // >>>0xc    ubytele    2e    \b
        off = pageOff + 12
        {
          iv, ok := readUint8be(tb, off)
          m3 = ok && (int64(int8(iv)) > 0x2e)
        }
        if m3 {
          out = append(out, "\\b")
        }

        if m3 {
          // >>>>0xa    ubytele    20    
          off = pageOff + 10
          {
            iv, ok := readUint8be(tb, off)
            m4 = ok && (int64(int8(iv)) > 0x20)
          }

          if m4 {
            // >>>>>0xa    ubytele    2e    
            off = pageOff + 10
            {
              iv, ok := readUint8be(tb, off)
              m5 = ok && (uint64(iv) != 0x2e)
            }

            if m5 {
              // >>>>>>0xa    ubytele    2a    \b%c
              off = pageOff + 10
              {
                iv, ok := readUint8be(tb, off)
                m6 = ok && (uint64(iv) != 0x2a)
              }
              if m6 {
                out = append(out, "\\b%c")
              }

            }
          }
          // >>>>0xb    ubytele    20    
          off = pageOff + 11
          {
            iv, ok := readUint8be(tb, off)
            m4 = ok && (int64(int8(iv)) > 0x20)
          }

          if m4 {
            // >>>>>0xb    ubytele    2e    \b%c
            off = pageOff + 11
            {
              iv, ok := readUint8be(tb, off)
              m5 = ok && (uint64(iv) != 0x2e)
            }
            if m5 {
              out = append(out, "\\b%c")
            }

          }
          // >>>>0xc    ubytele    20    
          off = pageOff + 12
          {
            iv, ok := readUint8be(tb, off)
            m4 = ok && (int64(int8(iv)) > 0x20)
          }

          if m4 {
            // >>>>>0xc    ubytele    39    
            off = pageOff + 12
            {
              iv, ok := readUint8be(tb, off)
              m5 = ok && (uint64(iv) != 0x39)
            }

            if m5 {
              // >>>>>>0xc    ubytele    2e    \b%c
              off = pageOff + 12
              {
                iv, ok := readUint8be(tb, off)
                m6 = ok && (uint64(iv) != 0x2e)
              }
              if m6 {
                out = append(out, "\\b%c")
              }

            }
          }
        }
        // >>>0xd    ubytele    20    
        off = pageOff + 13
        {
          iv, ok := readUint8be(tb, off)
          m3 = ok && (int64(int8(iv)) > 0x20)
        }

        if m3 {
          // >>>>0xd    ubytele    2e    \b%c
          off = pageOff + 13
          {
            iv, ok := readUint8be(tb, off)
            m4 = ok && (uint64(iv) != 0x2e)
          }
          if m4 {
            out = append(out, "\\b%c")
          }

          // >>>>0xe    ubytele    20    
          off = pageOff + 14
          {
            iv, ok := readUint8be(tb, off)
            m4 = ok && (int64(int8(iv)) > 0x20)
          }

          if m4 {
            // >>>>>0xe    ubytele    2e    \b%c
            off = pageOff + 14
            {
              iv, ok := readUint8be(tb, off)
              m5 = ok && (uint64(iv) != 0x2e)
            }
            if m5 {
              out = append(out, "\\b%c")
            }

          }
          // >>>>0xf    ubytele    20    
          off = pageOff + 15
          {
            iv, ok := readUint8be(tb, off)
            m4 = ok && (int64(int8(iv)) > 0x20)
          }

          if m4 {
            // >>>>>0xf    ubytele    2e    \b%c
            off = pageOff + 15
            {
              iv, ok := readUint8be(tb, off)
              m5 = ok && (uint64(iv) != 0x2e)
            }
            if m5 {
              out = append(out, "\\b%c")
            }

          }
          // >>>>0x10    ubytele    20    
          off = pageOff + 16
          {
            iv, ok := readUint8be(tb, off)
            m4 = ok && (int64(int8(iv)) > 0x20)
          }

          if m4 {
            // >>>>>0x10    ubytele    2e    
            off = pageOff + 16
            {
              iv, ok := readUint8be(tb, off)
              m5 = ok && (uint64(iv) != 0x2e)
            }

            if m5 {
              // >>>>>>0x10    ubytele    cb    \b%c
              off = pageOff + 16
              {
                iv, ok := readUint8be(tb, off)
                m6 = ok && (int64(int8(iv)) < 0xcb)
              }
              if m6 {
                out = append(out, "\\b%c")
              }

            }
          }
          // >>>>0x11    ubytele    20    
          off = pageOff + 17
          {
            iv, ok := readUint8be(tb, off)
            m4 = ok && (int64(int8(iv)) > 0x20)
          }

          if m4 {
            // >>>>>0x11    ubytele    2e    
            off = pageOff + 17
            {
              iv, ok := readUint8be(tb, off)
              m5 = ok && (uint64(iv) != 0x2e)
            }

            if m5 {
              // >>>>>>0x11    ubytele    90    \b%c
              off = pageOff + 17
              {
                iv, ok := readUint8be(tb, off)
                m6 = ok && (int64(int8(iv)) < 0x90)
              }
              if m6 {
                out = append(out, "\\b%c")
              }

            }
          }
        }
        // >>>0xc    ubytele    2f    
        off = pageOff + 12
        {
          iv, ok := readUint8be(tb, off)
          m3 = ok && (int64(int8(iv)) < 0x2f)
        }

        if m3 {
          // >>>>0x16    string    ">."    %-.6s
          off = pageOff + 22
          // uh oh unhandled kind
          if m4 {
            out = append(out, "%-.6s")
          }

        }
      }
    }
    // >0x4    ushortle    0&0x8000    
    off = pageOff + 4
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }

    if m1 {
      // >>0x4    ushortle    2&0x2    \b,32-bit sector-
      off = pageOff + 4
      {
        iv, ok := readUint16be(tb, off)
        m2 = ok && (uint64(iv) == 0x2)
      }
      if m2 {
        out = append(out, "\\b,32-bit sector-")
      }

    }
    // >0x4    ushortle    40&0x40    \b,IOCTL-
    off = pageOff + 4
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x40)
    }
    if m1 {
      out = append(out, "\\b,IOCTL-")
    }

    // >0x4    ushortle    800&0x800    \b,close media-
    off = pageOff + 4
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x800)
    }
    if m1 {
      out = append(out, "\\b,close media-")
    }

    // >0x4    ushortle    8000&0x8000    
    off = pageOff + 4
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x8000)
    }

    if m1 {
      // >>0x4    ushortle    2000&0x2000    \b,until busy-
      off = pageOff + 4
      {
        iv, ok := readUint16be(tb, off)
        m2 = ok && (uint64(iv) == 0x2000)
      }
      if m2 {
        out = append(out, "\\b,until busy-")
      }

    }
    // >0x4    ushortle    4000&0x4000    \b,control strings-
    off = pageOff + 4
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x4000)
    }
    if m1 {
      out = append(out, "\\b,control strings-")
    }

    // >0x4    ushortle    8000&0x8000    
    off = pageOff + 4
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x8000)
    }

    if m1 {
      // >>0x4    ushortle    0&0x6840    \bsupport
      off = pageOff + 4
      {
        iv, ok := readUint16be(tb, off)
        m2 = ok && (int64(int16(iv)) > 0x0)
      }
      if m2 {
        out = append(out, "\\bsupport")
      }

    }
    // >0x4    ushortle    0&0x8000    
    off = pageOff + 4
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }

    if m1 {
      // >>0x4    ushortle    0&0x4842    \bsupport
      off = pageOff + 4
      {
        iv, ok := readUint16be(tb, off)
        m2 = ok && (int64(int16(iv)) > 0x0)
      }
      if m2 {
        out = append(out, "\\bsupport")
      }

    }
    // >0x0    ubytele    0    \b)
    off = pageOff + 0
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      out = append(out, "\\b)")
    }

  }
  return out, nil
}

func IdentifyMsdosCom(tb []byte, pageOff int64) ([]string, error) {
  var out []string
  var off int64
  m0 := false
  m1 := false

  if m0 {
    // >0x0    bytele    0    DOS executable (COM)
    off = pageOff + 0
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      out = append(out, "DOS executable (COM)")
    }

    // >0x6    string    "SFX of LHarc"    \b, %s
    off = pageOff + 6
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, %s")
    }

    // >0x1fe    shortle    aa55    \b, boot code
    off = pageOff + 510
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xaa55)
    }
    if m1 {
      out = append(out, "\\b, boot code")
    }

    // >0x55    string    "UPX"    \b, UPX compressed
    off = pageOff + 85
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, UPX compressed")
    }

    // >0x4    string    " $ARX"    \b, ARX self-extracting archive
    off = pageOff + 4
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, ARX self-extracting archive")
    }

    // >0x4    string    " $LHarc"    \b, LHarc self-extracting archive
    off = pageOff + 4
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, LHarc self-extracting archive")
    }

    // >0x20e    string    "SFX by LARC"    \b, LARC self-extracting archive
    off = pageOff + 526
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, LARC self-extracting archive")
    }

  }
  return out, nil
}

func IdentifyLotusCells(tb []byte, pageOff int64) ([]string, error) {
  var out []string
  var off int64
  m0 := false
  m1 := false
  m2 := false
  m3 := false

  if m0 {
    // >0x0    ulongbe    6000800    \b, cell range
    off = pageOff + 0
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) == 0x6000800)
    }
    if m1 {
      out = append(out, "\\b, cell range")
    }

    if m1 {
      // >>0x4    ulongle    0    
      off = pageOff + 4
      {
        iv, ok := readUint32be(tb, off)
        m2 = ok && (uint64(iv) != 0x0)
      }

      if m2 {
        // >>>0x4    ushortle    0    \b%d,
        off = pageOff + 4
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x0)
        }
        if m3 {
          out = append(out, "\\b%d,")
        }

        // >>>0x6    ushortle    0    \b%d-
        off = pageOff + 6
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x0)
        }
        if m3 {
          out = append(out, "\\b%d-")
        }

      }
      // >>0x8    ushortle    0    \b%d,
      off = pageOff + 8
      {
        iv, ok := readUint16be(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }
      if m2 {
        out = append(out, "\\b%d,")
      }

      // >>0xa    ushortle    0    \b%d
      off = pageOff + 10
      {
        iv, ok := readUint16be(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }
      if m2 {
        out = append(out, "\\b%d")
      }

    }
  }
  return out, nil
}

func IdentifyCurIcoDir(tb []byte, pageOff int64) ([]string, error) {
  var out []string
  var off int64
  m0 := false
  m1 := false
  m2 := false
  m3 := false
  m4 := false

  if m0 {
    if m1 {
      // >>(0x12.longle)    ulongle    0    MS Windows
      // uh oh indirect offset
      {
        iv, ok := readUint32be(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }
      if m2 {
        out = append(out, "MS Windows")
      }

      if m2 {
        // >>>0x0    ulongbe    100    icon resource
        off = pageOff + 0
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x100)
        }
        if m3 {
          out = append(out, "icon resource")
        }

        if m3 {
          // >>>>0x4    ushortle    0    - %d icon
          off = pageOff + 4
          {
            iv, ok := readUint16be(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }
          if m4 {
            out = append(out, "- %d icon")
          }

          // >>>>0x4    ushortle    1    \bs
          off = pageOff + 4
          {
            iv, ok := readUint16be(tb, off)
            m4 = ok && (int64(int16(iv)) > 0x1)
          }
          if m4 {
            out = append(out, "\\bs")
          }

          // >>>>0x6    use   ico-entry    
          off = pageOff + 6
          // uh oh unhandled kind

          // >>>>0x4    ushortle    1    
          off = pageOff + 4
          {
            iv, ok := readUint16be(tb, off)
            m4 = ok && (int64(int16(iv)) > 0x1)
          }

          if m4 {
            // >>>>>0x16    use   ico-entry    
            off = pageOff + 22
            // uh oh unhandled kind

          }
        }
        // >>>0x0    ulongbe    200    cursor resource
        off = pageOff + 0
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x200)
        }
        if m3 {
          out = append(out, "cursor resource")
        }

        if m3 {
          // >>>>0x4    ushortle    0    - %d icon
          off = pageOff + 4
          {
            iv, ok := readUint16be(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }
          if m4 {
            out = append(out, "- %d icon")
          }

          // >>>>0x4    ushortle    1    \bs
          off = pageOff + 4
          {
            iv, ok := readUint16be(tb, off)
            m4 = ok && (int64(int16(iv)) > 0x1)
          }
          if m4 {
            out = append(out, "\\bs")
          }

          // >>>>0x6    use   cur-entry    
          off = pageOff + 6
          // uh oh unhandled kind

        }
      }
    }
  }
  return out, nil
}

func IdentifyCurEntry(tb []byte, pageOff int64) ([]string, error) {
  var out []string
  var off int64
  m0 := false
  m1 := false

  if m0 {
    // >0x0    use   cur-ico-entry    
    off = pageOff + 0
    // uh oh unhandled kind

    // >0x4    ushortle    0    \b, hotspot @%dx
    off = pageOff + 4
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      out = append(out, "\\b, hotspot @%dx")
    }

    // >0x6    ushortle    0    \b%d
    off = pageOff + 6
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      out = append(out, "\\b%d")
    }

  }
  return out, nil
}

func IdentifyLotusCells__Swapped(tb []byte, pageOff int64) ([]string, error) {
  var out []string
  var off int64
  m0 := false
  m1 := false
  m2 := false
  m3 := false

  if m0 {
    // >0x0    ulongbe    6000800    \b, cell range
    off = pageOff + 0
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) == 0x6000800)
    }
    if m1 {
      out = append(out, "\\b, cell range")
    }

    if m1 {
      // >>0x4    ulongle    0    
      off = pageOff + 4
      {
        iv, ok := readUint32le(tb, off)
        m2 = ok && (uint64(iv) != 0x0)
      }

      if m2 {
        // >>>0x4    ushortle    0    \b%d,
        off = pageOff + 4
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x0)
        }
        if m3 {
          out = append(out, "\\b%d,")
        }

        // >>>0x6    ushortle    0    \b%d-
        off = pageOff + 6
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x0)
        }
        if m3 {
          out = append(out, "\\b%d-")
        }

      }
      // >>0x8    ushortle    0    \b%d,
      off = pageOff + 8
      {
        iv, ok := readUint16le(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }
      if m2 {
        out = append(out, "\\b%d,")
      }

      // >>0xa    ushortle    0    \b%d
      off = pageOff + 10
      {
        iv, ok := readUint16le(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }
      if m2 {
        out = append(out, "\\b%d")
      }

    }
  }
  return out, nil
}

func IdentifyCurIcoDir__Swapped(tb []byte, pageOff int64) ([]string, error) {
  var out []string
  var off int64
  m0 := false
  m1 := false
  m2 := false
  m3 := false
  m4 := false

  if m0 {
    if m1 {
      // >>(0x12.longle)    ulongle    0    MS Windows
      // uh oh indirect offset
      {
        iv, ok := readUint32le(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }
      if m2 {
        out = append(out, "MS Windows")
      }

      if m2 {
        // >>>0x0    ulongbe    100    icon resource
        off = pageOff + 0
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x100)
        }
        if m3 {
          out = append(out, "icon resource")
        }

        if m3 {
          // >>>>0x4    ushortle    0    - %d icon
          off = pageOff + 4
          {
            iv, ok := readUint16le(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }
          if m4 {
            out = append(out, "- %d icon")
          }

          // >>>>0x4    ushortle    1    \bs
          off = pageOff + 4
          {
            iv, ok := readUint16le(tb, off)
            m4 = ok && (int64(int16(iv)) > 0x1)
          }
          if m4 {
            out = append(out, "\\bs")
          }

          // >>>>0x6    use   ico-entry    
          off = pageOff + 6
          // uh oh unhandled kind

          // >>>>0x4    ushortle    1    
          off = pageOff + 4
          {
            iv, ok := readUint16le(tb, off)
            m4 = ok && (int64(int16(iv)) > 0x1)
          }

          if m4 {
            // >>>>>0x16    use   ico-entry    
            off = pageOff + 22
            // uh oh unhandled kind

          }
        }
        // >>>0x0    ulongbe    200    cursor resource
        off = pageOff + 0
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x200)
        }
        if m3 {
          out = append(out, "cursor resource")
        }

        if m3 {
          // >>>>0x4    ushortle    0    - %d icon
          off = pageOff + 4
          {
            iv, ok := readUint16le(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }
          if m4 {
            out = append(out, "- %d icon")
          }

          // >>>>0x4    ushortle    1    \bs
          off = pageOff + 4
          {
            iv, ok := readUint16le(tb, off)
            m4 = ok && (int64(int16(iv)) > 0x1)
          }
          if m4 {
            out = append(out, "\\bs")
          }

          // >>>>0x6    use   cur-entry    
          off = pageOff + 6
          // uh oh unhandled kind

        }
      }
    }
  }
  return out, nil
}

func IdentifyCurEntry__Swapped(tb []byte, pageOff int64) ([]string, error) {
  var out []string
  var off int64
  m0 := false
  m1 := false

  if m0 {
    // >0x0    use   cur-ico-entry    
    off = pageOff + 0
    // uh oh unhandled kind

    // >0x4    ushortle    0    \b, hotspot @%dx
    off = pageOff + 4
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      out = append(out, "\\b, hotspot @%dx")
    }

    // >0x6    ushortle    0    \b%d
    off = pageOff + 6
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      out = append(out, "\\b%d")
    }

  }
  return out, nil
}

func IdentifyCurIcoEntry__Swapped(tb []byte, pageOff int64) ([]string, error) {
  var out []string
  var off int64
  m0 := false
  m1 := false

  if m0 {
    // >0x0    bytele    0    \b, 256x
    off = pageOff + 0
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      out = append(out, "\\b, 256x")
    }

    // >0x0    bytele    0    \b, %dx
    off = pageOff + 0
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) != 0x0)
    }
    if m1 {
      out = append(out, "\\b, %dx")
    }

    // >0x1    bytele    0    \b256
    off = pageOff + 1
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      out = append(out, "\\b256")
    }

    // >0x1    bytele    0    \b%d
    off = pageOff + 1
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) != 0x0)
    }
    if m1 {
      out = append(out, "\\b%d")
    }

    // >0x2    ubytele    0    \b, %d colors
    off = pageOff + 2
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) != 0x0)
    }
    if m1 {
      out = append(out, "\\b, %d colors")
    }

    // >(0xc.longle)    ulongbe    89504e47    
    // uh oh indirect offset
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) == 0x89504e47)
    }

    // >(0xc.longle)    ulongbe    89504e47    
    // uh oh indirect offset
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) != 0x89504e47)
    }

  }
  return out, nil
}

func Identify__Swapped(tb []byte, pageOff int64) ([]string, error) {
  var out []string
  var off int64
  m0 := false
  m1 := false
  m2 := false
  m3 := false
  m4 := false
  m5 := false
  m6 := false

  // 0x0    string    "\u007fELF"    ELF
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "ELF")
  }

  if m0 {
    // >0x4    bytele    0    invalid class
    off = pageOff + 4
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      out = append(out, "invalid class")
    }

    // >0x4    bytele    1    32-bit
    off = pageOff + 4
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) == 0x1)
    }
    if m1 {
      out = append(out, "32-bit")
    }

    // >0x4    bytele    2    64-bit
    off = pageOff + 4
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) == 0x2)
    }
    if m1 {
      out = append(out, "64-bit")
    }

    // >0x5    bytele    0    invalid byte order
    off = pageOff + 5
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      out = append(out, "invalid byte order")
    }

    // >0x5    bytele    1    LSB
    off = pageOff + 5
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) == 0x1)
    }
    if m1 {
      out = append(out, "LSB")
    }

    if m1 {
      // >>0x0    use   elf-le    
      off = pageOff + 0
      // uh oh unhandled kind

    }
    // >0x5    bytele    2    MSB
    off = pageOff + 5
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) == 0x2)
    }
    if m1 {
      out = append(out, "MSB")
    }

    if m1 {
      // >>0x0    use   \^elf-le    
      off = pageOff + 0
      // uh oh unhandled kind

    }
    // >0x4    bytele    80    
    off = pageOff + 4
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (int64(int8(iv)) < 0x80)
    }

    if m1 {
      // >>0x8    string    ">\x00"    (%s)
      off = pageOff + 8
      // uh oh unhandled kind
      if m2 {
        out = append(out, "(%s)")
      }

    }
    // >0x8    string    "\x00"    
    off = pageOff + 8
    // uh oh unhandled kind

    if m1 {
      // >>0x7    bytele    0    (SYSV)
      off = pageOff + 7
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }
      if m2 {
        out = append(out, "(SYSV)")
      }

      // >>0x7    bytele    1    (HP-UX)
      off = pageOff + 7
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x1)
      }
      if m2 {
        out = append(out, "(HP-UX)")
      }

      // >>0x7    bytele    2    (NetBSD)
      off = pageOff + 7
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x2)
      }
      if m2 {
        out = append(out, "(NetBSD)")
      }

      // >>0x7    bytele    3    (GNU/Linux)
      off = pageOff + 7
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x3)
      }
      if m2 {
        out = append(out, "(GNU/Linux)")
      }

      // >>0x7    bytele    4    (GNU/Hurd)
      off = pageOff + 7
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x4)
      }
      if m2 {
        out = append(out, "(GNU/Hurd)")
      }

      // >>0x7    bytele    5    (86Open)
      off = pageOff + 7
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x5)
      }
      if m2 {
        out = append(out, "(86Open)")
      }

      // >>0x7    bytele    6    (Solaris)
      off = pageOff + 7
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x6)
      }
      if m2 {
        out = append(out, "(Solaris)")
      }

      // >>0x7    bytele    7    (Monterey)
      off = pageOff + 7
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x7)
      }
      if m2 {
        out = append(out, "(Monterey)")
      }

      // >>0x7    bytele    8    (IRIX)
      off = pageOff + 7
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x8)
      }
      if m2 {
        out = append(out, "(IRIX)")
      }

      // >>0x7    bytele    9    (FreeBSD)
      off = pageOff + 7
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x9)
      }
      if m2 {
        out = append(out, "(FreeBSD)")
      }

      // >>0x7    bytele    a    (Tru64)
      off = pageOff + 7
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0xa)
      }
      if m2 {
        out = append(out, "(Tru64)")
      }

      // >>0x7    bytele    b    (Novell Modesto)
      off = pageOff + 7
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0xb)
      }
      if m2 {
        out = append(out, "(Novell Modesto)")
      }

      // >>0x7    bytele    c    (OpenBSD)
      off = pageOff + 7
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0xc)
      }
      if m2 {
        out = append(out, "(OpenBSD)")
      }

    }
    // >0x8    string    "\x02"    
    off = pageOff + 8
    // uh oh unhandled kind

    if m1 {
      // >>0x7    bytele    d    (OpenVMS)
      off = pageOff + 7
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0xd)
      }
      if m2 {
        out = append(out, "(OpenVMS)")
      }

      // >>0x7    bytele    61    (ARM)
      off = pageOff + 7
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x61)
      }
      if m2 {
        out = append(out, "(ARM)")
      }

      // >>0x7    bytele    ff    (embedded)
      off = pageOff + 7
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0xff)
      }
      if m2 {
        out = append(out, "(embedded)")
      }

    }
  }
  // 0x0    string    "@"    
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0x1    string    " echo off"    DOS batch file text
    off = pageOff + 1
    // uh oh unhandled kind
    if m1 {
      out = append(out, "DOS batch file text")
    }

    // >0x1    string    "echo off"    DOS batch file text
    off = pageOff + 1
    // uh oh unhandled kind
    if m1 {
      out = append(out, "DOS batch file text")
    }

    // >0x1    string    "rem"    DOS batch file text
    off = pageOff + 1
    // uh oh unhandled kind
    if m1 {
      out = append(out, "DOS batch file text")
    }

    // >0x1    string    "set "    DOS batch file text
    off = pageOff + 1
    // uh oh unhandled kind
    if m1 {
      out = append(out, "DOS batch file text")
    }

  }
  // 0x64    search/0xffff    "rxfuncadd"    
  off = pageOff + 100
  // uh oh unhandled kind

  // 0x64    search/0xffff    "say"    
  off = pageOff + 100
  // uh oh unhandled kind

  // 0x0    shortle    166    MS Windows COFF MIPS R4000 object file
  off = pageOff + 0
  {
    iv, ok := readUint16le(tb, off)
    m0 = ok && (uint64(iv) == 0x166)
  }
  if m0 {
    out = append(out, "MS Windows COFF MIPS R4000 object file")
  }

  // 0x0    shortle    184    MS Windows COFF Alpha object file
  off = pageOff + 0
  {
    iv, ok := readUint16le(tb, off)
    m0 = ok && (uint64(iv) == 0x184)
  }
  if m0 {
    out = append(out, "MS Windows COFF Alpha object file")
  }

  // 0x0    shortle    268    MS Windows COFF Motorola 68000 object file
  off = pageOff + 0
  {
    iv, ok := readUint16le(tb, off)
    m0 = ok && (uint64(iv) == 0x268)
  }
  if m0 {
    out = append(out, "MS Windows COFF Motorola 68000 object file")
  }

  // 0x0    shortle    1f0    MS Windows COFF PowerPC object file
  off = pageOff + 0
  {
    iv, ok := readUint16le(tb, off)
    m0 = ok && (uint64(iv) == 0x1f0)
  }
  if m0 {
    out = append(out, "MS Windows COFF PowerPC object file")
  }

  // 0x0    shortle    290    MS Windows COFF PA-RISC object file
  off = pageOff + 0
  {
    iv, ok := readUint16le(tb, off)
    m0 = ok && (uint64(iv) == 0x290)
  }
  if m0 {
    out = append(out, "MS Windows COFF PA-RISC object file")
  }

  // 0x0    string    "MZ"    
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0x18    shortle    40    MS-DOS executable
    off = pageOff + 24
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (int64(int16(iv)) < 0x40)
    }
    if m1 {
      out = append(out, "MS-DOS executable")
    }

    // >0x18    shortle    3f    
    off = pageOff + 24
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (int64(int16(iv)) > 0x3f)
    }

    if m1 {
      // >>(0x3c.longle)    string    "PE\x00\x00"    PE
      // uh oh indirect offset
      // uh oh unhandled kind
      if m2 {
        out = append(out, "PE")
      }

      if m2 {
        // >>>(0x3c.longle+24)    shortle    10b    \b32 executable
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x10b)
        }
        if m3 {
          out = append(out, "\\b32 executable")
        }

        // >>>(0x3c.longle+24)    shortle    20b    \b32+ executable
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x20b)
        }
        if m3 {
          out = append(out, "\\b32+ executable")
        }

        // >>>(0x3c.longle+24)    shortle    107    ROM image
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x107)
        }
        if m3 {
          out = append(out, "ROM image")
        }

        // >>>(0x3c.longle+24)    default    Unknown PE signature
        // uh oh indirect offset
        // uh oh unhandled kind
        if m3 {
          out = append(out, "Unknown PE signature")
        }

        if m3 {
          // >>>>&0x0    shortle    0    0x%x
          off = pageOff + 0
          {
            iv, ok := readUint16le(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }
          if m4 {
            out = append(out, "0x%x")
          }

        }
        // >>>(0x3c.longle+22)    shortle    0&0x2000    (DLL)
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (int64(int16(iv)) > 0x0)
        }
        if m3 {
          out = append(out, "(DLL)")
        }

        // >>>(0x3c.longle+92)    shortle    1    (native)
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x1)
        }
        if m3 {
          out = append(out, "(native)")
        }

        // >>>(0x3c.longle+92)    shortle    2    (GUI)
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x2)
        }
        if m3 {
          out = append(out, "(GUI)")
        }

        // >>>(0x3c.longle+92)    shortle    3    (console)
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x3)
        }
        if m3 {
          out = append(out, "(console)")
        }

        // >>>(0x3c.longle+92)    shortle    7    (POSIX)
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x7)
        }
        if m3 {
          out = append(out, "(POSIX)")
        }

        // >>>(0x3c.longle+92)    shortle    9    (Windows CE)
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x9)
        }
        if m3 {
          out = append(out, "(Windows CE)")
        }

        // >>>(0x3c.longle+92)    shortle    a    (EFI application)
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0xa)
        }
        if m3 {
          out = append(out, "(EFI application)")
        }

        // >>>(0x3c.longle+92)    shortle    b    (EFI boot service driver)
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0xb)
        }
        if m3 {
          out = append(out, "(EFI boot service driver)")
        }

        // >>>(0x3c.longle+92)    shortle    c    (EFI runtime driver)
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0xc)
        }
        if m3 {
          out = append(out, "(EFI runtime driver)")
        }

        // >>>(0x3c.longle+92)    shortle    d    (EFI ROM)
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0xd)
        }
        if m3 {
          out = append(out, "(EFI ROM)")
        }

        // >>>(0x3c.longle+92)    shortle    e    (XBOX)
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0xe)
        }
        if m3 {
          out = append(out, "(XBOX)")
        }

        // >>>(0x3c.longle+92)    shortle    f    (Windows boot application)
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0xf)
        }
        if m3 {
          out = append(out, "(Windows boot application)")
        }

        // >>>(0x3c.longle+92)    default    (Unknown subsystem
        // uh oh indirect offset
        // uh oh unhandled kind
        if m3 {
          out = append(out, "(Unknown subsystem")
        }

        if m3 {
          // >>>>&0x0    shortle    0    0x%x)
          off = pageOff + 0
          {
            iv, ok := readUint16le(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }
          if m4 {
            out = append(out, "0x%x)")
          }

        }
        // >>>(0x3c.longle+4)    shortle    14c    Intel 80386
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x14c)
        }
        if m3 {
          out = append(out, "Intel 80386")
        }

        // >>>(0x3c.longle+4)    shortle    166    MIPS R4000
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x166)
        }
        if m3 {
          out = append(out, "MIPS R4000")
        }

        // >>>(0x3c.longle+4)    shortle    168    MIPS R10000
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x168)
        }
        if m3 {
          out = append(out, "MIPS R10000")
        }

        // >>>(0x3c.longle+4)    shortle    184    Alpha
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x184)
        }
        if m3 {
          out = append(out, "Alpha")
        }

        // >>>(0x3c.longle+4)    shortle    1a2    Hitachi SH3
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x1a2)
        }
        if m3 {
          out = append(out, "Hitachi SH3")
        }

        // >>>(0x3c.longle+4)    shortle    1a6    Hitachi SH4
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x1a6)
        }
        if m3 {
          out = append(out, "Hitachi SH4")
        }

        // >>>(0x3c.longle+4)    shortle    1c0    ARM
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x1c0)
        }
        if m3 {
          out = append(out, "ARM")
        }

        // >>>(0x3c.longle+4)    shortle    1c2    ARM Thumb
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x1c2)
        }
        if m3 {
          out = append(out, "ARM Thumb")
        }

        // >>>(0x3c.longle+4)    shortle    1c4    ARMv7 Thumb
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x1c4)
        }
        if m3 {
          out = append(out, "ARMv7 Thumb")
        }

        // >>>(0x3c.longle+4)    shortle    1f0    PowerPC
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x1f0)
        }
        if m3 {
          out = append(out, "PowerPC")
        }

        // >>>(0x3c.longle+4)    shortle    200    Intel Itanium
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x200)
        }
        if m3 {
          out = append(out, "Intel Itanium")
        }

        // >>>(0x3c.longle+4)    shortle    266    MIPS16
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x266)
        }
        if m3 {
          out = append(out, "MIPS16")
        }

        // >>>(0x3c.longle+4)    shortle    268    Motorola 68000
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x268)
        }
        if m3 {
          out = append(out, "Motorola 68000")
        }

        // >>>(0x3c.longle+4)    shortle    290    PA-RISC
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x290)
        }
        if m3 {
          out = append(out, "PA-RISC")
        }

        // >>>(0x3c.longle+4)    shortle    366    MIPSIV
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x366)
        }
        if m3 {
          out = append(out, "MIPSIV")
        }

        // >>>(0x3c.longle+4)    shortle    466    MIPS16 with FPU
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x466)
        }
        if m3 {
          out = append(out, "MIPS16 with FPU")
        }

        // >>>(0x3c.longle+4)    shortle    ebc    EFI byte code
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0xebc)
        }
        if m3 {
          out = append(out, "EFI byte code")
        }

        // >>>(0x3c.longle+4)    shortle    8664    x86-64
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x8664)
        }
        if m3 {
          out = append(out, "x86-64")
        }

        // >>>(0x3c.longle+4)    shortle    c0ee    MSIL
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0xc0ee)
        }
        if m3 {
          out = append(out, "MSIL")
        }

        // >>>(0x3c.longle+4)    default    Unknown processor type
        // uh oh indirect offset
        // uh oh unhandled kind
        if m3 {
          out = append(out, "Unknown processor type")
        }

        if m3 {
          // >>>>&0x0    shortle    0    0x%x
          off = pageOff + 0
          {
            iv, ok := readUint16le(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }
          if m4 {
            out = append(out, "0x%x")
          }

        }
        // >>>(0x3c.longle+22)    shortle    0&0x200    (stripped to external PDB)
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (int64(int16(iv)) > 0x0)
        }
        if m3 {
          out = append(out, "(stripped to external PDB)")
        }

        // >>>(0x3c.longle+22)    shortle    0&0x1000    system file
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (int64(int16(iv)) > 0x0)
        }
        if m3 {
          out = append(out, "system file")
        }

        // >>>(0x3c.longle+24)    shortle    10b    
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x10b)
        }

        if m3 {
          // >>>>(0x3c.longle+232)    longle    0    Mono/.Net assembly
          // uh oh indirect offset
          {
            iv, ok := readUint32le(tb, off)
            m4 = ok && (int64(int32(iv)) > 0x0)
          }
          if m4 {
            out = append(out, "Mono/.Net assembly")
          }

        }
        // >>>(0x3c.longle+24)    shortle    20b    
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x20b)
        }

        if m3 {
          // >>>>(0x3c.longle+248)    longle    0    Mono/.Net assembly
          // uh oh indirect offset
          {
            iv, ok := readUint32le(tb, off)
            m4 = ok && (int64(int32(iv)) > 0x0)
          }
          if m4 {
            out = append(out, "Mono/.Net assembly")
          }

        }
        // >>>(0x8.shortle*16)    string    "32STUB"    \b, 32rtm DOS extender
        // uh oh indirect offset
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, 32rtm DOS extender")
        }

        // >>>(0x8.shortle*16)    string    "32STUB"    \b, for MS Windows
        // uh oh indirect offset
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, for MS Windows")
        }

        // >>>(0x3c.longle+248)    string    "UPX0"    \b, UPX compressed
        // uh oh indirect offset
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, UPX compressed")
        }

        // >>>(0x3c.longle+248)    search/0x140    "PEC2"    \b, PECompact2 compressed
        // uh oh indirect offset
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, PECompact2 compressed")
        }

        // >>>(0x3c.longle+248)    search/0x140    "UPX2"    
        // uh oh indirect offset
        // uh oh unhandled kind

        if m3 {
          // >>>>(&0x10.longle+(-4))    string    "PK\x03\x04"    \b, ZIP self-extracting archive (Info-Zip)
          // uh oh indirect offset
          // uh oh unhandled kind
          if m4 {
            out = append(out, "\\b, ZIP self-extracting archive (Info-Zip)")
          }

        }
        // >>>(0x3c.longle+248)    search/0x140    ".idata"    
        // uh oh indirect offset
        // uh oh unhandled kind

        if m3 {
          // >>>>(&0xe.longle+(-4))    string    "PK\x03\x04"    \b, ZIP self-extracting archive (Info-Zip)
          // uh oh indirect offset
          // uh oh unhandled kind
          if m4 {
            out = append(out, "\\b, ZIP self-extracting archive (Info-Zip)")
          }

          // >>>>(&0xe.longle+(-4))    string    "ZZ0"    \b, ZZip self-extracting archive
          // uh oh indirect offset
          // uh oh unhandled kind
          if m4 {
            out = append(out, "\\b, ZZip self-extracting archive")
          }

          // >>>>(&0xe.longle+(-4))    string    "ZZ1"    \b, ZZip self-extracting archive
          // uh oh indirect offset
          // uh oh unhandled kind
          if m4 {
            out = append(out, "\\b, ZZip self-extracting archive")
          }

        }
        // >>>(0x3c.longle+248)    search/0x140    ".rsrc"    
        // uh oh indirect offset
        // uh oh unhandled kind

        if m3 {
          // >>>>(&0xf.longle+(-4))    string    "a\\\x04\x05"    \b, WinHKI self-extracting archive
          // uh oh indirect offset
          // uh oh unhandled kind
          if m4 {
            out = append(out, "\\b, WinHKI self-extracting archive")
          }

          // >>>>(&0xf.longle+(-4))    string    "Rar!"    \b, RAR self-extracting archive
          // uh oh indirect offset
          // uh oh unhandled kind
          if m4 {
            out = append(out, "\\b, RAR self-extracting archive")
          }

          // >>>>(&0xf.longle+(-4))    search/0x3000    "MSCF"    \b, InstallShield self-extracting archive
          // uh oh indirect offset
          // uh oh unhandled kind
          if m4 {
            out = append(out, "\\b, InstallShield self-extracting archive")
          }

          // >>>>(&0xf.longle+(-4))    search/0x20    "Nullsoft"    \b, Nullsoft Installer self-extracting archive
          // uh oh indirect offset
          // uh oh unhandled kind
          if m4 {
            out = append(out, "\\b, Nullsoft Installer self-extracting archive")
          }

        }
        // >>>(0x3c.longle+248)    search/0x140    ".data"    
        // uh oh indirect offset
        // uh oh unhandled kind

        if m3 {
          // >>>>(&0xf.longle)    string    "WEXTRACT"    \b, MS CAB-Installer self-extracting archive
          // uh oh indirect offset
          // uh oh unhandled kind
          if m4 {
            out = append(out, "\\b, MS CAB-Installer self-extracting archive")
          }

        }
        // >>>(0x3c.longle+248)    search/0x140    ".petite\x00"    \b, Petite compressed
        // uh oh indirect offset
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, Petite compressed")
        }

        if m3 {
          // >>>>(0x3c.longle+247)    bytele    0    
          // uh oh indirect offset
          {
            iv, ok := readUint8le(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }

          if m4 {
            // >>>>>(&0x104.longle+(-4))    string    "=!sfx!"    \b, ACE self-extracting archive
            // uh oh indirect offset
            // uh oh unhandled kind
            if m5 {
              out = append(out, "\\b, ACE self-extracting archive")
            }

          }
        }
        // >>>(0x3c.longle+248)    search/0x140    ".WISE"    \b, WISE installer self-extracting archive
        // uh oh indirect offset
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, WISE installer self-extracting archive")
        }

        // >>>(0x3c.longle+248)    search/0x140    ".dz\x00\x00\x00"    \b, Dzip self-extracting archive
        // uh oh indirect offset
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, Dzip self-extracting archive")
        }

        // >>>&(0x3c.longle+248)    search/0x100    "_winzip_"    \b, ZIP self-extracting archive (WinZip)
        // uh oh indirect offset
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, ZIP self-extracting archive (WinZip)")
        }

        // >>>&(0x3c.longle+248)    search/0x100    "SharedD"    \b, Microsoft Installer self-extracting archive
        // uh oh indirect offset
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, Microsoft Installer self-extracting archive")
        }

        // >>>0x30    string    "Inno"    \b, InnoSetup self-extracting archive
        off = pageOff + 48
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, InnoSetup self-extracting archive")
        }

      }
      // >>(0x3c.longle)    string    "PE\x00\x00"    MS-DOS executable
      // uh oh indirect offset
      // uh oh unhandled kind
      if m2 {
        out = append(out, "MS-DOS executable")
      }

      // >>(0x3c.longle)    string    "NE"    \b, NE
      // uh oh indirect offset
      // uh oh unhandled kind
      if m2 {
        out = append(out, "\\b, NE")
      }

      if m2 {
        // >>>(0x3c.longle+54)    bytele    1    for OS/2 1.x
        // uh oh indirect offset
        {
          iv, ok := readUint8le(tb, off)
          m3 = ok && (uint64(iv) == 0x1)
        }
        if m3 {
          out = append(out, "for OS/2 1.x")
        }

        // >>>(0x3c.longle+54)    bytele    2    for MS Windows 3.x
        // uh oh indirect offset
        {
          iv, ok := readUint8le(tb, off)
          m3 = ok && (uint64(iv) == 0x2)
        }
        if m3 {
          out = append(out, "for MS Windows 3.x")
        }

        // >>>(0x3c.longle+54)    bytele    3    for MS-DOS
        // uh oh indirect offset
        {
          iv, ok := readUint8le(tb, off)
          m3 = ok && (uint64(iv) == 0x3)
        }
        if m3 {
          out = append(out, "for MS-DOS")
        }

        // >>>(0x3c.longle+54)    bytele    4    for Windows 386
        // uh oh indirect offset
        {
          iv, ok := readUint8le(tb, off)
          m3 = ok && (uint64(iv) == 0x4)
        }
        if m3 {
          out = append(out, "for Windows 386")
        }

        // >>>(0x3c.longle+54)    bytele    5    for Borland Operating System Services
        // uh oh indirect offset
        {
          iv, ok := readUint8le(tb, off)
          m3 = ok && (uint64(iv) == 0x5)
        }
        if m3 {
          out = append(out, "for Borland Operating System Services")
        }

        // >>>(0x3c.longle+54)    default    
        // uh oh indirect offset
        // uh oh unhandled kind

        if m3 {
          // >>>>(0x3c.longle+54)    bytele    0    (unknown OS %x)
          // uh oh indirect offset
          {
            iv, ok := readUint8le(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }
          if m4 {
            out = append(out, "(unknown OS %x)")
          }

        }
        // >>>(0x3c.longle+54)    bytele    81    for MS-DOS, Phar Lap DOS extender
        // uh oh indirect offset
        {
          iv, ok := readUint8le(tb, off)
          m3 = ok && (uint64(iv) == 0x81)
        }
        if m3 {
          out = append(out, "for MS-DOS, Phar Lap DOS extender")
        }

        // >>>(0x3c.longle+12)    shortle    8002&0x8003    (DLL)
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x8002)
        }
        if m3 {
          out = append(out, "(DLL)")
        }

        // >>>(0x3c.longle+12)    shortle    8001&0x8003    (driver)
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x8001)
        }
        if m3 {
          out = append(out, "(driver)")
        }

        // >>>&(&0x24.shortle-1)    string    "ARJSFX"    \b, ARJ self-extracting archive
        // uh oh indirect offset
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, ARJ self-extracting archive")
        }

        // >>>(0x3c.longle+112)    search/0x80    "WinZip(R) Self-Extractor"    \b, ZIP self-extracting archive (WinZip)
        // uh oh indirect offset
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, ZIP self-extracting archive (WinZip)")
        }

      }
      // >>(0x3c.longle)    string    "LX\x00\x00"    \b, LX
      // uh oh indirect offset
      // uh oh unhandled kind
      if m2 {
        out = append(out, "\\b, LX")
      }

      if m2 {
        // >>>(0x3c.longle+10)    shortle    1    (unknown OS)
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (int64(int16(iv)) < 0x1)
        }
        if m3 {
          out = append(out, "(unknown OS)")
        }

        // >>>(0x3c.longle+10)    shortle    1    for OS/2
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x1)
        }
        if m3 {
          out = append(out, "for OS/2")
        }

        // >>>(0x3c.longle+10)    shortle    2    for MS Windows
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x2)
        }
        if m3 {
          out = append(out, "for MS Windows")
        }

        // >>>(0x3c.longle+10)    shortle    3    for DOS
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x3)
        }
        if m3 {
          out = append(out, "for DOS")
        }

        // >>>(0x3c.longle+10)    shortle    3    (unknown OS)
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (int64(int16(iv)) > 0x3)
        }
        if m3 {
          out = append(out, "(unknown OS)")
        }

        // >>>(0x3c.longle+16)    longle    8000&0x28000    (DLL)
        // uh oh indirect offset
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x8000)
        }
        if m3 {
          out = append(out, "(DLL)")
        }

        // >>>(0x3c.longle+16)    longle    0&0x20000    (device driver)
        // uh oh indirect offset
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (int64(int32(iv)) > 0x0)
        }
        if m3 {
          out = append(out, "(device driver)")
        }

        // >>>(0x3c.longle+16)    longle    300&0x300    (GUI)
        // uh oh indirect offset
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x300)
        }
        if m3 {
          out = append(out, "(GUI)")
        }

        // >>>(0x3c.longle+16)    longle    300&0x28300    (console)
        // uh oh indirect offset
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (int64(int32(iv)) < 0x300)
        }
        if m3 {
          out = append(out, "(console)")
        }

        // >>>(0x3c.longle+8)    shortle    1    i80286
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x1)
        }
        if m3 {
          out = append(out, "i80286")
        }

        // >>>(0x3c.longle+8)    shortle    2    i80386
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x2)
        }
        if m3 {
          out = append(out, "i80386")
        }

        // >>>(0x3c.longle+8)    shortle    3    i80486
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x3)
        }
        if m3 {
          out = append(out, "i80486")
        }

        // >>>(0x8.shortle*16)    string    "emx"    \b, emx
        // uh oh indirect offset
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, emx")
        }

        if m3 {
          // >>>>&0x1    string    "x"    %s
          off = pageOff + 1
          // uh oh unhandled kind
          if m4 {
            out = append(out, "%s")
          }

        }
        // >>>&(&0x54.longle-3)    string    "arjsfx"    \b, ARJ self-extracting archive
        // uh oh indirect offset
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, ARJ self-extracting archive")
        }

      }
      // >>(0x3c.longle)    string    "W3"    \b, W3 for MS Windows
      // uh oh indirect offset
      // uh oh unhandled kind
      if m2 {
        out = append(out, "\\b, W3 for MS Windows")
      }

      // >>(0x3c.longle)    string    "LE\x00\x00"    \b, LE executable
      // uh oh indirect offset
      // uh oh unhandled kind
      if m2 {
        out = append(out, "\\b, LE executable")
      }

      if m2 {
        // >>>(0x3c.longle+10)    shortle    1    
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x1)
        }

        if m3 {
          // >>>>0x240    search/0x100    "DOS/4G"    for MS-DOS, DOS4GW DOS extender
          off = pageOff + 576
          // uh oh unhandled kind
          if m4 {
            out = append(out, "for MS-DOS, DOS4GW DOS extender")
          }

          // >>>>0x240    search/0x200    "WATCOM C/C++"    for MS-DOS, DOS4GW DOS extender
          off = pageOff + 576
          // uh oh unhandled kind
          if m4 {
            out = append(out, "for MS-DOS, DOS4GW DOS extender")
          }

          // >>>>0x440    search/0x100    "CauseWay DOS Extender"    for MS-DOS, CauseWay DOS extender
          off = pageOff + 1088
          // uh oh unhandled kind
          if m4 {
            out = append(out, "for MS-DOS, CauseWay DOS extender")
          }

          // >>>>0x40    search/0x40    "PMODE/W"    for MS-DOS, PMODE/W DOS extender
          off = pageOff + 64
          // uh oh unhandled kind
          if m4 {
            out = append(out, "for MS-DOS, PMODE/W DOS extender")
          }

          // >>>>0x40    search/0x40    "STUB/32A"    for MS-DOS, DOS/32A DOS extender (stub)
          off = pageOff + 64
          // uh oh unhandled kind
          if m4 {
            out = append(out, "for MS-DOS, DOS/32A DOS extender (stub)")
          }

          // >>>>0x40    search/0x80    "STUB/32C"    for MS-DOS, DOS/32A DOS extender (configurable stub)
          off = pageOff + 64
          // uh oh unhandled kind
          if m4 {
            out = append(out, "for MS-DOS, DOS/32A DOS extender (configurable stub)")
          }

          // >>>>0x40    search/0x80    "DOS/32A"    for MS-DOS, DOS/32A DOS extender (embedded)
          off = pageOff + 64
          // uh oh unhandled kind
          if m4 {
            out = append(out, "for MS-DOS, DOS/32A DOS extender (embedded)")
          }

          // >>>>&0x24    longle    50    
          off = pageOff + 36
          {
            iv, ok := readUint32le(tb, off)
            m4 = ok && (int64(int32(iv)) < 0x50)
          }

          if m4 {
            // >>>>>(&0x4c.longle)    string    "\xfc\xb8WATCOM"    
            // uh oh indirect offset
            // uh oh unhandled kind

            if m5 {
              // >>>>>>&0x0    search/0x8    "3\xdbf\xb9"    \b, 32Lite compressed
              off = pageOff + 0
              // uh oh unhandled kind
              if m6 {
                out = append(out, "\\b, 32Lite compressed")
              }

            }
          }
        }
        // >>>(0x3c.longle+10)    shortle    2    for MS Windows
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x2)
        }
        if m3 {
          out = append(out, "for MS Windows")
        }

        // >>>(0x3c.longle+10)    shortle    3    for DOS
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x3)
        }
        if m3 {
          out = append(out, "for DOS")
        }

        // >>>(0x3c.longle+10)    shortle    4    for MS Windows (VxD)
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x4)
        }
        if m3 {
          out = append(out, "for MS Windows (VxD)")
        }

        // >>>(&0x7c.longle+38)    string    "UPX"    \b, UPX compressed
        // uh oh indirect offset
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, UPX compressed")
        }

        // >>>&(&0x54.longle-3)    string    "UNACE"    \b, ACE self-extracting archive
        // uh oh indirect offset
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, ACE self-extracting archive")
        }

      }
      // >>0x3c    longle    20000000    
      off = pageOff + 60
      {
        iv, ok := readUint32le(tb, off)
        m2 = ok && (int64(int32(iv)) > 0x20000000)
      }

      if m2 {
        // >>>(0x4.shortle*512)    shortle    14c    \b, MZ for MS-DOS
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) != 0x14c)
        }
        if m3 {
          out = append(out, "\\b, MZ for MS-DOS")
        }

      }
    }
    // >0x2    longle    0    
    off = pageOff + 2
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) != 0x0)
    }

    if m1 {
      // >>0x18    shortle    40    
      off = pageOff + 24
      {
        iv, ok := readUint16le(tb, off)
        m2 = ok && (int64(int16(iv)) < 0x40)
      }

      if m2 {
        // >>>(0x4.shortle*512)    shortle    14c    
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) != 0x14c)
        }

        if m3 {
          // >>>>&(0x2.shortle-514)    string    "LE"    
          // uh oh indirect offset
          // uh oh unhandled kind

          if m4 {
            // >>>>>&0x-2    string    "BW"    \b, MZ for MS-DOS
            off = pageOff + -2
            // uh oh unhandled kind
            if m5 {
              out = append(out, "\\b, MZ for MS-DOS")
            }

          }
          // >>>>&(0x2.shortle-514)    string    "LE"    \b, LE
          // uh oh indirect offset
          // uh oh unhandled kind
          if m4 {
            out = append(out, "\\b, LE")
          }

          if m4 {
            // >>>>>0x240    search/0x100    "DOS/4G"    for MS-DOS, DOS4GW DOS extender
            off = pageOff + 576
            // uh oh unhandled kind
            if m5 {
              out = append(out, "for MS-DOS, DOS4GW DOS extender")
            }

          }
          // >>>>&(0x2.shortle-514)    string    "BW"    
          // uh oh indirect offset
          // uh oh unhandled kind

          if m4 {
            // >>>>>0x240    search/0x100    "DOS/4G"    \b, LE for MS-DOS, DOS4GW DOS extender (embedded)
            off = pageOff + 576
            // uh oh unhandled kind
            if m5 {
              out = append(out, "\\b, LE for MS-DOS, DOS4GW DOS extender (embedded)")
            }

            // >>>>>0x240    search/0x100    "!DOS/4G"    \b, BW collection for MS-DOS
            off = pageOff + 576
            // uh oh unhandled kind
            if m5 {
              out = append(out, "\\b, BW collection for MS-DOS")
            }

          }
        }
      }
    }
    // >(0x4.shortle*512)    shortle    14c    \b, COFF
    // uh oh indirect offset
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x14c)
    }
    if m1 {
      out = append(out, "\\b, COFF")
    }

    if m1 {
      // >>(0x8.shortle*16)    string    "go32stub"    for MS-DOS, DJGPP go32 DOS extender
      // uh oh indirect offset
      // uh oh unhandled kind
      if m2 {
        out = append(out, "for MS-DOS, DJGPP go32 DOS extender")
      }

      // >>(0x8.shortle*16)    string    "emx"    
      // uh oh indirect offset
      // uh oh unhandled kind

      if m2 {
        // >>>&0x1    string    "x"    for DOS, Win or OS/2, emx %s
        off = pageOff + 1
        // uh oh unhandled kind
        if m3 {
          out = append(out, "for DOS, Win or OS/2, emx %s")
        }

      }
      // >>&(&0x42.longle-3)    bytele    0    
      // uh oh indirect offset
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }

      if m2 {
        // >>>&0x26    string    "UPX"    \b, UPX compressed
        off = pageOff + 38
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, UPX compressed")
        }

      }
      // >>&0x2c    search/0xa0    ".text"    
      off = pageOff + 44
      // uh oh unhandled kind

      if m2 {
        // >>>&0xb    longle    2000    
        off = pageOff + 11
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (int64(int32(iv)) < 0x2000)
        }

        if m3 {
          // >>>>&0x0    longle    6000    \b, 32lite compressed
          off = pageOff + 0
          {
            iv, ok := readUint32le(tb, off)
            m4 = ok && (int64(int32(iv)) > 0x6000)
          }
          if m4 {
            out = append(out, "\\b, 32lite compressed")
          }

        }
      }
    }
    // >(0x8.shortle*16)    string    "$WdX"    \b, WDos/X DOS extender
    // uh oh indirect offset
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, WDos/X DOS extender")
    }

    // >0x35    string    "\x8e\xc0\xb9\b\x00\xf3\xa5Ju\xeb\x8e\xd83\xff\xbe0\x00\x05"    \b, aPack compressed
    off = pageOff + 53
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, aPack compressed")
    }

    // >0xe7    string    "LH/2 "    Self-Extract \b, %s
    off = pageOff + 231
    // uh oh unhandled kind
    if m1 {
      out = append(out, "Self-Extract \\b, %s")
    }

    // >0x1c    string    "UC2X"    \b, UCEXE compressed
    off = pageOff + 28
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, UCEXE compressed")
    }

    // >0x1c    string    "WWP "    \b, WWPACK compressed
    off = pageOff + 28
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, WWPACK compressed")
    }

    // >0x1c    string    "RJSX"    \b, ARJ self-extracting archive
    off = pageOff + 28
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, ARJ self-extracting archive")
    }

    // >0x1c    string    "diet"    \b, diet compressed
    off = pageOff + 28
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, diet compressed")
    }

    // >0x1c    string    "LZ09"    \b, LZEXE v0.90 compressed
    off = pageOff + 28
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, LZEXE v0.90 compressed")
    }

    // >0x1c    string    "LZ91"    \b, LZEXE v0.91 compressed
    off = pageOff + 28
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, LZEXE v0.91 compressed")
    }

    // >0x1c    string    "tz"    \b, TinyProg compressed
    off = pageOff + 28
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, TinyProg compressed")
    }

    // >0x1e    string    "Copyright 1989-1990 PKWARE Inc."    Self-extracting PKZIP archive
    off = pageOff + 30
    // uh oh unhandled kind
    if m1 {
      out = append(out, "Self-extracting PKZIP archive")
    }

    // >0x1e    string    "PKLITE Copr."    Self-extracting PKZIP archive
    off = pageOff + 30
    // uh oh unhandled kind
    if m1 {
      out = append(out, "Self-extracting PKZIP archive")
    }

    // >0x20    search/0xe0    "aRJsfX"    \b, ARJ self-extracting archive
    off = pageOff + 32
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, ARJ self-extracting archive")
    }

    // >0x20    string    "AIN"    
    off = pageOff + 32
    // uh oh unhandled kind

    if m1 {
      // >>0x23    string    "2"    \b, AIN 2.x compressed
      off = pageOff + 35
      // uh oh unhandled kind
      if m2 {
        out = append(out, "\\b, AIN 2.x compressed")
      }

      // >>0x23    string    "<2"    \b, AIN 1.x compressed
      off = pageOff + 35
      // uh oh unhandled kind
      if m2 {
        out = append(out, "\\b, AIN 1.x compressed")
      }

      // >>0x23    string    ">2"    \b, AIN 1.x compressed
      off = pageOff + 35
      // uh oh unhandled kind
      if m2 {
        out = append(out, "\\b, AIN 1.x compressed")
      }

    }
    // >0x24    string    "LHa's SFX"    \b, LHa self-extracting archive
    off = pageOff + 36
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, LHa self-extracting archive")
    }

    // >0x24    string    "LHA's SFX"    \b, LHa self-extracting archive
    off = pageOff + 36
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, LHa self-extracting archive")
    }

    // >0x24    string    " $ARX"    \b, ARX self-extracting archive
    off = pageOff + 36
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, ARX self-extracting archive")
    }

    // >0x24    string    " $LHarc"    \b, LHarc self-extracting archive
    off = pageOff + 36
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, LHarc self-extracting archive")
    }

    // >0x20    string    "SFX by LARC"    \b, LARC self-extracting archive
    off = pageOff + 32
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, LARC self-extracting archive")
    }

    // >0x40    string    "aPKG"    \b, aPackage self-extracting archive
    off = pageOff + 64
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, aPackage self-extracting archive")
    }

    // >0x64    string    "W Collis\x00\x00"    \b, Compack compressed
    off = pageOff + 100
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, Compack compressed")
    }

    // >0x7a    string    "Windows self-extracting ZIP"    \b, ZIP self-extracting archive
    off = pageOff + 122
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, ZIP self-extracting archive")
    }

    if m1 {
      // >>&0xf4    search/0x140    "\x00@\x01\x00"    
      off = pageOff + 244
      // uh oh unhandled kind

      if m2 {
        // >>>(&0x0.longle+(4))    string    "MSCF"    \b, WinHKI CAB self-extracting archive
        // uh oh indirect offset
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, WinHKI CAB self-extracting archive")
        }

      }
    }
    // >0x666    string    "-lh5-"    \b, LHa self-extracting archive v2.13S
    off = pageOff + 1638
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, LHa self-extracting archive v2.13S")
    }

    // >0x17888    string    "Rar!"    \b, RAR self-extracting archive
    off = pageOff + 96392
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, RAR self-extracting archive")
    }

    // >(0x4.shortle*512)    longle    0    
    // uh oh indirect offset
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }

    if m1 {
      // >>&(0x2.shortle-517)    bytele    0    
      // uh oh indirect offset
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }

      if m2 {
        // >>>&0x0    string    "PK\x03\x04"    \b, ZIP self-extracting archive
        off = pageOff + 0
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, ZIP self-extracting archive")
        }

        // >>>&0x0    string    "Rar!"    \b, RAR self-extracting archive
        off = pageOff + 0
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, RAR self-extracting archive")
        }

        // >>>&0x0    string    "=!\x11"    \b, AIN 2.x self-extracting archive
        off = pageOff + 0
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, AIN 2.x self-extracting archive")
        }

        // >>>&0x0    string    "=!\x12"    \b, AIN 2.x self-extracting archive
        off = pageOff + 0
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, AIN 2.x self-extracting archive")
        }

        // >>>&0x0    string    "=!\x17"    \b, AIN 1.x self-extracting archive
        off = pageOff + 0
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, AIN 1.x self-extracting archive")
        }

        // >>>&0x0    string    "=!\x18"    \b, AIN 1.x self-extracting archive
        off = pageOff + 0
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, AIN 1.x self-extracting archive")
        }

        // >>>&0x7    search/0x190    "**ACE**"    \b, ACE self-extracting archive
        off = pageOff + 7
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, ACE self-extracting archive")
        }

        // >>>&0x0    search/0x480    "UC2SFX Header"    \b, UC2 self-extracting archive
        off = pageOff + 0
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, UC2 self-extracting archive")
        }

      }
    }
    // >(0x8.shortle*16)    search/0x20    "PKSFX"    \b, ZIP self-extracting archive (PKZIP)
    // uh oh indirect offset
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, ZIP self-extracting archive (PKZIP)")
    }

    // >0xc289    string    "y\xff\x80\xffv\xff"    \b, CODEC archive v3.21
    off = pageOff + 49801
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, CODEC archive v3.21")
    }

    if m1 {
      // >>0xc2a0    shortle    1    \b, 1 file
      off = pageOff + 49824
      {
        iv, ok := readUint16le(tb, off)
        m2 = ok && (uint64(iv) == 0x1)
      }
      if m2 {
        out = append(out, "\\b, 1 file")
      }

      // >>0xc2a0    shortle    1    \b, %u files
      off = pageOff + 49824
      {
        iv, ok := readUint16le(tb, off)
        m2 = ok && (int64(int16(iv)) > 0x1)
      }
      if m2 {
        out = append(out, "\\b, %u files")
      }

    }
  }
  // 0x0    string    "KCF"    FreeDOS KEYBoard Layout collection
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "FreeDOS KEYBoard Layout collection")
  }

  if m0 {
    // >0x3    ushortle    0    \b, version 0x%x
    off = pageOff + 3
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      out = append(out, "\\b, version 0x%x")
    }

    // >0x6    ubytele    0    
    off = pageOff + 6
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (int64(int8(iv)) > 0x0)
    }

    if m1 {
      // >>0x7    string    ">\x00"    \b, author=%-.14s
      off = pageOff + 7
      // uh oh unhandled kind
      if m2 {
        out = append(out, "\\b, author=%-.14s")
      }

      // >>0x7    search/0xfe    "\xff"    \b, info=
      off = pageOff + 7
      // uh oh unhandled kind
      if m2 {
        out = append(out, "\\b, info=")
      }

      if m2 {
        // >>>&0x0    string    "x"    \b%-.15s
        off = pageOff + 0
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b%-.15s")
        }

      }
    }
  }
  // 0x0    string    "KLF"    FreeDOS KEYBoard Layout file
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "FreeDOS KEYBoard Layout file")
  }

  if m0 {
    // >0x3    ushortle    0    \b, version 0x%x
    off = pageOff + 3
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      out = append(out, "\\b, version 0x%x")
    }

    // >0x5    ubytele    0    
    off = pageOff + 5
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (int64(int8(iv)) > 0x0)
    }

    if m1 {
      // >>0x8    string    "x"    \b, name=%-.2s
      off = pageOff + 8
      // uh oh unhandled kind
      if m2 {
        out = append(out, "\\b, name=%-.2s")
      }

    }
  }
  // 0x0    string    "\xffKEYB   \x00\x00\x00\x00"    
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0xc    string    "\x00\x00\x00\x00`\x04\xf0"    MS-DOS KEYBoard Layout file
    off = pageOff + 12
    // uh oh unhandled kind
    if m1 {
      out = append(out, "MS-DOS KEYBoard Layout file")
    }

  }
  // 0x0    uquadle    ffffffff&0x7a0ffffffff    
  off = pageOff + 0
  {
    iv, ok := readUint64le(tb, off)
    m0 = ok && (uint64(iv) == 0xffffffff)
  }

  if m0 {
    // >0x0    use   msdos-driver    
    off = pageOff + 0
    // uh oh unhandled kind

  }
  // 0x0    uquadle    513c00000000012    
  off = pageOff + 0
  {
    iv, ok := readUint64le(tb, off)
    m0 = ok && (uint64(iv) == 0x513c00000000012)
  }

  if m0 {
    // >0x0    use   msdos-driver    
    off = pageOff + 0
    // uh oh unhandled kind

  }
  // 0x0    uquadle    32f28000ffff0016    
  off = pageOff + 0
  {
    iv, ok := readUint64le(tb, off)
    m0 = ok && (uint64(iv) == 0x32f28000ffff0016)
  }

  if m0 {
    // >0x0    use   msdos-driver    
    off = pageOff + 0
    // uh oh unhandled kind

  }
  // 0x0    uquadle    7f00000000ffff    
  off = pageOff + 0
  {
    iv, ok := readUint64le(tb, off)
    m0 = ok && (uint64(iv) == 0x7f00000000ffff)
  }

  if m0 {
    // >0x0    use   msdos-driver    
    off = pageOff + 0
    // uh oh unhandled kind

  }
  // 0x0    uquadle    1600000000ffff    
  off = pageOff + 0
  {
    iv, ok := readUint64le(tb, off)
    m0 = ok && (uint64(iv) == 0x1600000000ffff)
  }

  if m0 {
    // >0x0    use   msdos-driver    
    off = pageOff + 0
    // uh oh unhandled kind

  }
  // 0x0    uquadle    bf708c2ffffffff    
  off = pageOff + 0
  {
    iv, ok := readUint64le(tb, off)
    m0 = ok && (uint64(iv) == 0xbf708c2ffffffff)
  }

  if m0 {
    // >0x0    use   msdos-driver    
    off = pageOff + 0
    // uh oh unhandled kind

  }
  // 0x0    uquadle    7bd08c2ffffffff    
  off = pageOff + 0
  {
    iv, ok := readUint64le(tb, off)
    m0 = ok && (uint64(iv) == 0x7bd08c2ffffffff)
  }

  if m0 {
    // >0x0    use   msdos-driver    
    off = pageOff + 0
    // uh oh unhandled kind

  }
  // 0x0    ubytele    8c    
  off = pageOff + 0
  {
    iv, ok := readUint8le(tb, off)
    m0 = ok && (uint64(iv) == 0x8c)
  }

  if m0 {
    // >0x4    string    "O===="    
    off = pageOff + 4
    // uh oh unhandled kind

    if m1 {
      // >>0x5    string    "MAIN"    
      off = pageOff + 5
      // uh oh unhandled kind

      if m2 {
        // >>>0x4    ubytele    d    DOS executable (COM, 0x8C-variant)
        off = pageOff + 4
        {
          iv, ok := readUint8le(tb, off)
          m3 = ok && (int64(int8(iv)) > 0xd)
        }
        if m3 {
          out = append(out, "DOS executable (COM, 0x8C-variant)")
        }

      }
    }
  }
  // 0x0    ulongle    ffff10eb    DR-DOS executable (COM)
  off = pageOff + 0
  {
    iv, ok := readUint32le(tb, off)
    m0 = ok && (uint64(iv) == 0xffff10eb)
  }
  if m0 {
    out = append(out, "DR-DOS executable (COM)")
  }

  // 0x0    ushortbe    eb00&0xeb8d    
  off = pageOff + 0
  {
    iv, ok := readUint16be(tb, off)
    m0 = ok && (int64(int16(iv)) > 0xeb00)
  }

  // 0x0    bytele    eb    
  off = pageOff + 0
  {
    iv, ok := readUint8le(tb, off)
    m0 = ok && (uint64(iv) == 0xeb)
  }

  if m0 {
    // >0x1    bytele    -1    
    off = pageOff + 1
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (int64(int8(iv)) > -1)
    }

    if m1 {
      // >>(0x1.bytele+2)    bytele    0    
      // uh oh indirect offset
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }

      if m2 {
        // >>>0x0    use   msdos-com    
        off = pageOff + 0
        // uh oh unhandled kind

      }
    }
  }
  // 0x0    bytele    e9    
  off = pageOff + 0
  {
    iv, ok := readUint8le(tb, off)
    m0 = ok && (uint64(iv) == 0xe9)
  }

  if m0 {
    // >0x1    shortle    -1    
    off = pageOff + 1
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (int64(int16(iv)) > -1)
    }

    if m1 {
      // >>(0x1.shortle+3)    bytele    0    
      // uh oh indirect offset
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }

      if m2 {
        // >>>0x0    use   msdos-com    
        off = pageOff + 0
        // uh oh unhandled kind

      }
    }
    // >0x1    shortle    -103    
    off = pageOff + 1
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (int64(int16(iv)) < -259)
    }

    if m1 {
      // >>(0x1.shortle+65539)    bytele    0    
      // uh oh indirect offset
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }

      if m2 {
        // >>>0x0    use   msdos-com    
        off = pageOff + 0
        // uh oh unhandled kind

      }
    }
  }
  // 0x0    ubytele    b8    
  off = pageOff + 0
  {
    iv, ok := readUint8le(tb, off)
    m0 = ok && (uint64(iv) == 0xb8)
  }

  if m0 {
    // >0x0    string    "\xb8\xc0\a\x8e"    
    off = pageOff + 0
    // uh oh unhandled kind

    if m1 {
      // >>0x1    longle    21cd4cfe&0xfffffffe    COM executable (32-bit COMBOOT
      off = pageOff + 1
      {
        iv, ok := readUint32le(tb, off)
        m2 = ok && (uint64(iv) == 0x21cd4cfe)
      }
      if m2 {
        out = append(out, "COM executable (32-bit COMBOOT")
      }

      if m2 {
        // >>>0x1    longle    21cd4cff    \b)
        off = pageOff + 1
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x21cd4cff)
        }
        if m3 {
          out = append(out, "\\b)")
        }

        // >>>0x1    longle    21cd4cfe    \b, relocatable)
        off = pageOff + 1
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x21cd4cfe)
        }
        if m3 {
          out = append(out, "\\b, relocatable)")
        }

      }
      // >>0x1    default    COM executable for DOS
      off = pageOff + 1
      // uh oh unhandled kind
      if m2 {
        out = append(out, "COM executable for DOS")
      }

    }
  }
  // 0x0    string    "\x81\xfc"    
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0x4    string    "w\x02\xcd \xb9"    
    off = pageOff + 4
    // uh oh unhandled kind

    if m1 {
      // >>0x24    string    "UPX!"    FREE-DOS executable (COM), UPX compressed
      off = pageOff + 36
      // uh oh unhandled kind
      if m2 {
        out = append(out, "FREE-DOS executable (COM), UPX compressed")
      }

    }
  }
  // 0xfc    string    "Must have DOS version"    DR-DOS executable (COM)
  off = pageOff + 252
  // uh oh unhandled kind
  if m0 {
    out = append(out, "DR-DOS executable (COM)")
  }

  // 0x22    string    "UPX!"    FREE-DOS executable (COM), UPX compressed
  off = pageOff + 34
  // uh oh unhandled kind
  if m0 {
    out = append(out, "FREE-DOS executable (COM), UPX compressed")
  }

  // 0x23    string    "UPX!"    FREE-DOS executable (COM), UPX compressed
  off = pageOff + 35
  // uh oh unhandled kind
  if m0 {
    out = append(out, "FREE-DOS executable (COM), UPX compressed")
  }

  // 0x2    string    "\xcd!"    COM executable for DOS
  off = pageOff + 2
  // uh oh unhandled kind
  if m0 {
    out = append(out, "COM executable for DOS")
  }

  // 0x4    string    "\xcd!"    COM executable for DOS
  off = pageOff + 4
  // uh oh unhandled kind
  if m0 {
    out = append(out, "COM executable for DOS")
  }

  // 0x5    string    "\xcd!"    COM executable for DOS
  off = pageOff + 5
  // uh oh unhandled kind
  if m0 {
    out = append(out, "COM executable for DOS")
  }

  // 0x7    string    "\xcd!"    
  off = pageOff + 7
  // uh oh unhandled kind

  if m0 {
    // >0x0    bytele    b8    COM executable for DOS
    off = pageOff + 0
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) != 0xb8)
    }
    if m1 {
      out = append(out, "COM executable for DOS")
    }

  }
  // 0xa    string    "\xcd!"    
  off = pageOff + 10
  // uh oh unhandled kind

  if m0 {
    // >0x5    string    "\xcd!"    COM executable for DOS
    off = pageOff + 5
    // uh oh unhandled kind
    if m1 {
      out = append(out, "COM executable for DOS")
    }

  }
  // 0xd    string    "\xcd!"    COM executable for DOS
  off = pageOff + 13
  // uh oh unhandled kind
  if m0 {
    out = append(out, "COM executable for DOS")
  }

  // 0x12    string    "\xcd!"    COM executable for MS-DOS
  off = pageOff + 18
  // uh oh unhandled kind
  if m0 {
    out = append(out, "COM executable for MS-DOS")
  }

  // 0x17    string    "\xcd!"    COM executable for MS-DOS
  off = pageOff + 23
  // uh oh unhandled kind
  if m0 {
    out = append(out, "COM executable for MS-DOS")
  }

  // 0x1e    string    "\xcd!"    COM executable for MS-DOS
  off = pageOff + 30
  // uh oh unhandled kind
  if m0 {
    out = append(out, "COM executable for MS-DOS")
  }

  // 0x46    string    "\xcd!"    COM executable for DOS
  off = pageOff + 70
  // uh oh unhandled kind
  if m0 {
    out = append(out, "COM executable for DOS")
  }

  // 0x6    search/0xa    "\xfcW\xf3\xa5\xc3"    COM executable for MS-DOS
  off = pageOff + 6
  // uh oh unhandled kind
  if m0 {
    out = append(out, "COM executable for MS-DOS")
  }

  // 0x6    search/0xa    "\xfcW\xf3\xa4\xc3"    COM executable for DOS
  off = pageOff + 6
  // uh oh unhandled kind
  if m0 {
    out = append(out, "COM executable for DOS")
  }

  if m0 {
    // >0x18    search/0x10    "P\xa4\xff\xd5s"    \b, aPack compressed
    off = pageOff + 24
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, aPack compressed")
    }

  }
  // 0x3c    string    "W Collis\x00\x00"    COM executable for MS-DOS, Compack compressed
  off = pageOff + 60
  // uh oh unhandled kind
  if m0 {
    out = append(out, "COM executable for MS-DOS, Compack compressed")
  }

  // 0x0    string    "LZ"    MS-DOS executable (built-in)
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "MS-DOS executable (built-in)")
  }

  // 0x0    string    "\xd0\xcf\x11\u0871\x1a\xe1AAFB\r\x00OM\x06\x0e+4\x01\x01\x01\xff"    AAF legacy file using MS Structured Storage
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "AAF legacy file using MS Structured Storage")
  }

  if m0 {
    // >0x1e    bytele    9    (512B sectors)
    off = pageOff + 30
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) == 0x9)
    }
    if m1 {
      out = append(out, "(512B sectors)")
    }

    // >0x1e    bytele    c    (4kB sectors)
    off = pageOff + 30
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) == 0xc)
    }
    if m1 {
      out = append(out, "(4kB sectors)")
    }

  }
  // 0x0    string    "\xd0\xcf\x11\u0871\x1a\xe1\x01\x02\x01\r\x00\x02\x00\x00\x06\x0e+4\x03\x02\x01\x01"    AAF file using MS Structured Storage
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "AAF file using MS Structured Storage")
  }

  if m0 {
    // >0x1e    bytele    9    (512B sectors)
    off = pageOff + 30
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) == 0x9)
    }
    if m1 {
      out = append(out, "(512B sectors)")
    }

    // >0x1e    bytele    c    (4kB sectors)
    off = pageOff + 30
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) == 0xc)
    }
    if m1 {
      out = append(out, "(4kB sectors)")
    }

  }
  // 0x820    string    "Microsoft Word 6.0 Document"    %s
  off = pageOff + 2080
  // uh oh unhandled kind
  if m0 {
    out = append(out, "%s")
  }

  // 0x820    string    "Documento Microsoft Word 6"    Spanish Microsoft Word 6 document data
  off = pageOff + 2080
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Spanish Microsoft Word 6 document data")
  }

  // 0x840    string    "MSWordDoc"    Microsoft Word document data
  off = pageOff + 2112
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Microsoft Word document data")
  }

  // 0x0    longbe    31be0000    Microsoft Word Document
  off = pageOff + 0
  {
    iv, ok := readUint32be(tb, off)
    m0 = ok && (uint64(iv) == 0x31be0000)
  }
  if m0 {
    out = append(out, "Microsoft Word Document")
  }

  // 0x0    string    "PO^Q`"    Microsoft Word 6.0 Document
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Microsoft Word 6.0 Document")
  }

  // 0x4    longle    0    
  off = pageOff + 4
  {
    iv, ok := readUint32le(tb, off)
    m0 = ok && (uint64(iv) == 0x0)
  }

  if m0 {
    // >0x0    longbe    fe320000    Microsoft Word for Macintosh 1.0
    off = pageOff + 0
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) == 0xfe320000)
    }
    if m1 {
      out = append(out, "Microsoft Word for Macintosh 1.0")
    }

    // >0x0    longbe    fe340000    Microsoft Word for Macintosh 3.0
    off = pageOff + 0
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) == 0xfe340000)
    }
    if m1 {
      out = append(out, "Microsoft Word for Macintosh 3.0")
    }

    // >0x0    longbe    fe37001c    Microsoft Word for Macintosh 4.0
    off = pageOff + 0
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) == 0xfe37001c)
    }
    if m1 {
      out = append(out, "Microsoft Word for Macintosh 4.0")
    }

    // >0x0    longbe    fe370023    Microsoft Word for Macintosh 5.0
    off = pageOff + 0
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) == 0xfe370023)
    }
    if m1 {
      out = append(out, "Microsoft Word for Macintosh 5.0")
    }

  }
  // 0x0    string    "-\x00\x00\x00"    Microsoft Word 2.0 Document
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Microsoft Word 2.0 Document")
  }

  // 0x200    string    "\xec\xa5\xc1"    Microsoft Word Document
  off = pageOff + 512
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Microsoft Word Document")
  }

  // 0x0    string    "-\x00"    Microsoft WinWord 2.0 Document
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Microsoft WinWord 2.0 Document")
  }

  // 0x820    string    "Microsoft Excel 5.0 Worksheet"    %s
  off = pageOff + 2080
  // uh oh unhandled kind
  if m0 {
    out = append(out, "%s")
  }

  // 0x0    string    "-\x00"    Microsoft WinWord 2.0 Document
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Microsoft WinWord 2.0 Document")
  }

  // 0x820    string    "Foglio di lavoro Microsoft Exce"    %s
  off = pageOff + 2080
  // uh oh unhandled kind
  if m0 {
    out = append(out, "%s")
  }

  // 0x842    string    "Biff5"    Microsoft Excel 5.0 Worksheet
  off = pageOff + 2114
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Microsoft Excel 5.0 Worksheet")
  }

  // 0x849    string    "Biff5"    Microsoft Excel 5.0 Worksheet
  off = pageOff + 2121
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Microsoft Excel 5.0 Worksheet")
  }

  // 0x0    string    "\t\x04\x06\x00\x00\x00\x10\x00"    Microsoft Excel Worksheet
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Microsoft Excel Worksheet")
  }

  // 0x0    longbe    1a00    
  off = pageOff + 0
  {
    iv, ok := readUint32be(tb, off)
    m0 = ok && (uint64(iv) == 0x1a00)
  }

  if m0 {
    // >0x14    ubytele    0    
    off = pageOff + 20
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (int64(int8(iv)) > 0x0)
    }

    if m1 {
      // >>0x14    ubytele    20    Lotus 1-2-3
      off = pageOff + 20
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (int64(int8(iv)) < 0x20)
      }
      if m2 {
        out = append(out, "Lotus 1-2-3")
      }

      if m2 {
        // >>>0x4    ushortle    1000    WorKsheet, version 3
        off = pageOff + 4
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x1000)
        }
        if m3 {
          out = append(out, "WorKsheet, version 3")
        }

        // >>>0x4    ushortle    1002    WorKsheet, version 4
        off = pageOff + 4
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x1002)
        }
        if m3 {
          out = append(out, "WorKsheet, version 4")
        }

        // >>>0x4    ushortle    1003    WorKsheet, version 97
        off = pageOff + 4
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x1003)
        }
        if m3 {
          out = append(out, "WorKsheet, version 97")
        }

        // >>>0x4    ushortle    1005    WorKsheet, version 9.8 Millennium
        off = pageOff + 4
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x1005)
        }
        if m3 {
          out = append(out, "WorKsheet, version 9.8 Millennium")
        }

        // >>>0x4    ushortle    8001    FoRMatting data
        off = pageOff + 4
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x8001)
        }
        if m3 {
          out = append(out, "FoRMatting data")
        }

        // >>>0x4    ushortle    8007    ForMatting data, version 3
        off = pageOff + 4
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x8007)
        }
        if m3 {
          out = append(out, "ForMatting data, version 3")
        }

        // >>>0x4    default    unknown
        off = pageOff + 4
        // uh oh unhandled kind
        if m3 {
          out = append(out, "unknown")
        }

        if m3 {
          // >>>>0x6    ushortle    4    worksheet
          off = pageOff + 6
          {
            iv, ok := readUint16le(tb, off)
            m4 = ok && (uint64(iv) == 0x4)
          }
          if m4 {
            out = append(out, "worksheet")
          }

          // >>>>0x6    ushortle    4    formatting data
          off = pageOff + 6
          {
            iv, ok := readUint16le(tb, off)
            m4 = ok && (uint64(iv) != 0x4)
          }
          if m4 {
            out = append(out, "formatting data")
          }

          // >>>>0x4    ushortle    0    \b, revision 0x%x
          off = pageOff + 4
          {
            iv, ok := readUint16le(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }
          if m4 {
            out = append(out, "\\b, revision 0x%x")
          }

        }
        // >>>0x6    ushortle    4    \b, cell range
        off = pageOff + 6
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x4)
        }
        if m3 {
          out = append(out, "\\b, cell range")
        }

        if m3 {
          // >>>>0x8    ulongle    0    
          off = pageOff + 8
          {
            iv, ok := readUint32le(tb, off)
            m4 = ok && (uint64(iv) != 0x0)
          }

          if m4 {
            // >>>>>0xa    ubytele    0    \b%d*
            off = pageOff + 10
            {
              iv, ok := readUint8le(tb, off)
              m5 = ok && (int64(int8(iv)) > 0x0)
            }
            if m5 {
              out = append(out, "\\b%d*")
            }

            // >>>>>0x8    ushortle    0    \b%d,
            off = pageOff + 8
            {
              iv, ok := readUint16le(tb, off)
              m5 = ok && (uint64(iv) == 0x0)
            }
            if m5 {
              out = append(out, "\\b%d,")
            }

            // >>>>>0xb    ubytele    0    \b%d-
            off = pageOff + 11
            {
              iv, ok := readUint8le(tb, off)
              m5 = ok && (uint64(iv) == 0x0)
            }
            if m5 {
              out = append(out, "\\b%d-")
            }

          }
          // >>>>0xe    ubytele    0    \b%d*
          off = pageOff + 14
          {
            iv, ok := readUint8le(tb, off)
            m4 = ok && (int64(int8(iv)) > 0x0)
          }
          if m4 {
            out = append(out, "\\b%d*")
          }

          // >>>>0xc    ushortle    0    \b%d,
          off = pageOff + 12
          {
            iv, ok := readUint16le(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }
          if m4 {
            out = append(out, "\\b%d,")
          }

          // >>>>0xf    ubytele    0    \b%d
          off = pageOff + 15
          {
            iv, ok := readUint8le(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }
          if m4 {
            out = append(out, "\\b%d")
          }

          // >>>>0x14    ubytele    1    \b, character set 0x%x
          off = pageOff + 20
          {
            iv, ok := readUint8le(tb, off)
            m4 = ok && (int64(int8(iv)) > 0x1)
          }
          if m4 {
            out = append(out, "\\b, character set 0x%x")
          }

          // >>>>0x15    ubytele    0    \b, flags 0x%x
          off = pageOff + 21
          {
            iv, ok := readUint8le(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }
          if m4 {
            out = append(out, "\\b, flags 0x%x")
          }

        }
        // >>>0x6    ushortle    4    
        off = pageOff + 6
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) != 0x4)
        }

        if m3 {
          // >>>>0x1e    search/0x1d    "\x00\xae"    
          off = pageOff + 30
          // uh oh unhandled kind

          if m4 {
            // >>>>>&0x4    string    ">\x00"    \b, 1st font "%s"
            off = pageOff + 4
            // uh oh unhandled kind
            if m5 {
              out = append(out, "\\b, 1st font \"%s\"")
            }

          }
        }
      }
    }
  }
  // 0x0    longbe    200    
  off = pageOff + 0
  {
    iv, ok := readUint32be(tb, off)
    m0 = ok && (uint64(iv) == 0x200)
  }

  if m0 {
    // >0x7    ubytele    0    
    off = pageOff + 7
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }

    if m1 {
      // >>0x6    ubytele    0    Lotus
      off = pageOff + 6
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (int64(int8(iv)) > 0x0)
      }
      if m2 {
        out = append(out, "Lotus")
      }

      if m2 {
        // >>>0x4    ushortle    7    1-2-3 CoNFiguration, version 2.x (PGRAPH.CNF)
        off = pageOff + 4
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x7)
        }
        if m3 {
          out = append(out, "1-2-3 CoNFiguration, version 2.x (PGRAPH.CNF)")
        }

        // >>>0x4    ushortle    c05    1-2-3 CoNFiguration, version 2.4J
        off = pageOff + 4
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0xc05)
        }
        if m3 {
          out = append(out, "1-2-3 CoNFiguration, version 2.4J")
        }

        // >>>0x4    ushortle    801    1-2-3 CoNFiguration, version 1-2.1
        off = pageOff + 4
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x801)
        }
        if m3 {
          out = append(out, "1-2-3 CoNFiguration, version 1-2.1")
        }

        // >>>0x4    ushortle    802    Symphony CoNFiguration
        off = pageOff + 4
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x802)
        }
        if m3 {
          out = append(out, "Symphony CoNFiguration")
        }

        // >>>0x4    ushortle    804    1-2-3 CoNFiguration, version 2.2
        off = pageOff + 4
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x804)
        }
        if m3 {
          out = append(out, "1-2-3 CoNFiguration, version 2.2")
        }

        // >>>0x4    ushortle    80a    1-2-3 CoNFiguration, version 2.3-2.4
        off = pageOff + 4
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x80a)
        }
        if m3 {
          out = append(out, "1-2-3 CoNFiguration, version 2.3-2.4")
        }

        // >>>0x4    ushortle    1402    1-2-3 CoNFiguration, version 3.x
        off = pageOff + 4
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x1402)
        }
        if m3 {
          out = append(out, "1-2-3 CoNFiguration, version 3.x")
        }

        // >>>0x4    ushortle    1450    1-2-3 CoNFiguration, version 4.x
        off = pageOff + 4
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x1450)
        }
        if m3 {
          out = append(out, "1-2-3 CoNFiguration, version 4.x")
        }

        // >>>0x4    ushortle    404    1-2-3 WorKSheet, version 1
        off = pageOff + 4
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x404)
        }
        if m3 {
          out = append(out, "1-2-3 WorKSheet, version 1")
        }

        // >>>0x4    ushortle    405    Symphony WoRksheet, version 1.0
        off = pageOff + 4
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x405)
        }
        if m3 {
          out = append(out, "Symphony WoRksheet, version 1.0")
        }

        // >>>0x4    ushortle    406    1-2-3/Symphony worksheet, version 2
        off = pageOff + 4
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x406)
        }
        if m3 {
          out = append(out, "1-2-3/Symphony worksheet, version 2")
        }

        // >>>0x4    ushortle    600    1-2-3 WorKsheet, version 1.xJ
        off = pageOff + 4
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x600)
        }
        if m3 {
          out = append(out, "1-2-3 WorKsheet, version 1.xJ")
        }

        // >>>0x4    ushortle    602    1-2-3 worksheet, version 2.4J
        off = pageOff + 4
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x602)
        }
        if m3 {
          out = append(out, "1-2-3 worksheet, version 2.4J")
        }

        // >>>0x4    ushortle    8006    1-2-3 ForMaTting data, version 2.x
        off = pageOff + 4
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x8006)
        }
        if m3 {
          out = append(out, "1-2-3 ForMaTting data, version 2.x")
        }

        // >>>0x4    ushortle    8007    1-2-3 FoRMatting data, version 2.0
        off = pageOff + 4
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x8007)
        }
        if m3 {
          out = append(out, "1-2-3 FoRMatting data, version 2.0")
        }

        // >>>0x4    default    unknown worksheet or configuration
        off = pageOff + 4
        // uh oh unhandled kind
        if m3 {
          out = append(out, "unknown worksheet or configuration")
        }

        if m3 {
          // >>>>0x4    ushortle    0    \b, revision 0x%x
          off = pageOff + 4
          {
            iv, ok := readUint16le(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }
          if m4 {
            out = append(out, "\\b, revision 0x%x")
          }

        }
        // >>>0x6    use   lotus-cells    
        off = pageOff + 6
        // uh oh unhandled kind

        // >>>(0x8.shortle+10)    use   lotus-cells    
        // uh oh indirect offset
        // uh oh unhandled kind

      }
    }
  }
  // 0x0    string    "WordPro\x00"    Lotus WordPro
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Lotus WordPro")
  }

  // 0x0    string    "WordPro\r\xfb"    Lotus WordPro
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Lotus WordPro")
  }

  // 0x0    string    "q\xa8\x00\x00\x01\x02"    
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0xc    string    "Stirling Technologies,"    InstallShield Uninstall Script
    off = pageOff + 12
    // uh oh unhandled kind
    if m1 {
      out = append(out, "InstallShield Uninstall Script")
    }

  }
  // 0x0    string    "Nullsoft AVS Preset "    Winamp plug in
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Winamp plug in")
  }

  // 0x0    string    "\xd7\xcd"    ms-windows metafont .wmf
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "ms-windows metafont .wmf")
  }

  // 0x0    string    "\x02\x00\t\x00"    ms-windows metafont .wmf
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "ms-windows metafont .wmf")
  }

  // 0x0    string    "\x01\x00\t\x00"    ms-windows metafont .wmf
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "ms-windows metafont .wmf")
  }

  // 0x0    string    "\x03\x01\x01\x048\x01\x00\x00"    tz3 ms-works file
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "tz3 ms-works file")
  }

  // 0x0    string    "\x03\x02\x01\x048\x01\x00\x00"    tz3 ms-works file
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "tz3 ms-works file")
  }

  // 0x0    string    "\x03\x03\x01\x048\x01\x00\x00"    tz3 ms-works file
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "tz3 ms-works file")
  }

  // 0x0    string    "\x89\x00?\x03\x05\x003\x9fW5\x17\xb6i4\x05%A\x9b\x11\x02"    PGP sig
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "PGP sig")
  }

  // 0x0    string    "\x89\x00?\x03\x05\x003\x9fW6\x17\xb6i4\x05%A\x9b\x11\x02"    PGP sig
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "PGP sig")
  }

  // 0x0    string    "\x89\x00?\x03\x05\x003\x9fW7\x17\xb6i4\x05%A\x9b\x11\x02"    PGP sig
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "PGP sig")
  }

  // 0x0    string    "\x89\x00?\x03\x05\x003\x9fW8\x17\xb6i4\x05%A\x9b\x11\x02"    PGP sig
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "PGP sig")
  }

  // 0x0    string    "\x89\x00?\x03\x05\x003\x9fW9\x17\xb6i4\x05%A\x9b\x11\x02"    PGP sig
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "PGP sig")
  }

  // 0x0    string    "\x89\x00\x95\x03\x05\x002R\x87\xc4@\xe5\""    PGP sig
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "PGP sig")
  }

  // 0x0    string    "MDIF\x1a\x00\b\x00\x00\x00\xfa&@}\x01\x00\x01\x1e\x01\x00"    MS Windows special zipped file
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "MS Windows special zipped file")
  }

  // 0x0    string    "BA(\x00\x00\x00.\x00\x00\x00\x00\x00\x00\x00"    Icon for MS Windows
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Icon for MS Windows")
  }

  // 0x0    longbe    100    
  off = pageOff + 0
  {
    iv, ok := readUint32be(tb, off)
    m0 = ok && (uint64(iv) == 0x100)
  }

  if m0 {
    // >0x9    bytele    0    
    off = pageOff + 9
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }

    if m1 {
      // >>0x0    bytele    0    
      off = pageOff + 0
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }

      // >>0x0    use   cur-ico-dir    
      off = pageOff + 0
      // uh oh unhandled kind

    }
    // >0x9    ubytele    ff    
    off = pageOff + 9
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) == 0xff)
    }

    if m1 {
      // >>0x0    bytele    0    
      off = pageOff + 0
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }

      // >>0x0    use   cur-ico-dir    
      off = pageOff + 0
      // uh oh unhandled kind

    }
  }
  // 0x0    longbe    200    
  off = pageOff + 0
  {
    iv, ok := readUint32be(tb, off)
    m0 = ok && (uint64(iv) == 0x200)
  }

  if m0 {
    // >0x9    bytele    0    
    off = pageOff + 9
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }

    if m1 {
      // >>0x0    use   cur-ico-dir    
      off = pageOff + 0
      // uh oh unhandled kind

    }
    // >0x9    ubytele    ff    
    off = pageOff + 9
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) == 0xff)
    }

    if m1 {
      // >>0x0    use   cur-ico-dir    
      off = pageOff + 0
      // uh oh unhandled kind

    }
  }
  // 0x0    string    "PK\b\bBGI"    Borland font
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Borland font")
  }

  if m0 {
    // >0x4    string    ">\x00"    %s
    off = pageOff + 4
    // uh oh unhandled kind
    if m1 {
      out = append(out, "%s")
    }

  }
  // 0x0    string    "pk\b\bBGI"    Borland device
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Borland device")
  }

  if m0 {
    // >0x4    string    ">\x00"    %s
    off = pageOff + 4
    // uh oh unhandled kind
    if m1 {
      out = append(out, "%s")
    }

  }
  // 0x0    longle    4    
  off = pageOff + 0
  {
    iv, ok := readUint32le(tb, off)
    m0 = ok && (uint64(iv) == 0x4)
  }

  if m0 {
    // >0xc    longle    118    Windows Recycle Bin INFO2 file (Win98 or below)
    off = pageOff + 12
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) == 0x118)
    }
    if m1 {
      out = append(out, "Windows Recycle Bin INFO2 file (Win98 or below)")
    }

  }
  // 0x0    longle    5    
  off = pageOff + 0
  {
    iv, ok := readUint32le(tb, off)
    m0 = ok && (uint64(iv) == 0x5)
  }

  if m0 {
    // >0xc    longle    320    Windows Recycle Bin INFO2 file (Win2k - WinXP)
    off = pageOff + 12
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) == 0x320)
    }
    if m1 {
      out = append(out, "Windows Recycle Bin INFO2 file (Win2k - WinXP)")
    }

  }
  // 0x9    string    "GERBILDOC"    First Choice document
  off = pageOff + 9
  // uh oh unhandled kind
  if m0 {
    out = append(out, "First Choice document")
  }

  // 0x9    string    "GERBILDB"    First Choice database
  off = pageOff + 9
  // uh oh unhandled kind
  if m0 {
    out = append(out, "First Choice database")
  }

  // 0x9    string    "GERBILCLIP"    First Choice database
  off = pageOff + 9
  // uh oh unhandled kind
  if m0 {
    out = append(out, "First Choice database")
  }

  // 0x0    string    "GERBIL"    First Choice device file
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "First Choice device file")
  }

  // 0x9    string    "RABBITGRAPH"    RabbitGraph file
  off = pageOff + 9
  // uh oh unhandled kind
  if m0 {
    out = append(out, "RabbitGraph file")
  }

  // 0x0    string    "DCU1"    Borland Delphi .DCU file
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Borland Delphi .DCU file")
  }

  // 0x0    string    "=!<spell>"    MKS Spell hash list (old format)
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "MKS Spell hash list (old format)")
  }

  // 0x0    string    "=!<spell2>"    MKS Spell hash list
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "MKS Spell hash list")
  }

  // 0x0    longle    8086b70    TurboC BGI file
  off = pageOff + 0
  {
    iv, ok := readUint32le(tb, off)
    m0 = ok && (uint64(iv) == 0x8086b70)
  }
  if m0 {
    out = append(out, "TurboC BGI file")
  }

  // 0x0    longle    8084b50    TurboC Font file
  off = pageOff + 0
  {
    iv, ok := readUint32le(tb, off)
    m0 = ok && (uint64(iv) == 0x8084b50)
  }
  if m0 {
    out = append(out, "TurboC Font file")
  }

  // 0x0    string    "TPF0"    
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "PMCC"    Windows 3.x .GRP file
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Windows 3.x .GRP file")
  }

  // 0x1    string    "RDC-meg"    MegaDots
  off = pageOff + 1
  // uh oh unhandled kind
  if m0 {
    out = append(out, "MegaDots")
  }

  if m0 {
    // >0x8    bytele    2f    version %c
    off = pageOff + 8
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (int64(int8(iv)) > 0x2f)
    }
    if m1 {
      out = append(out, "version %c")
    }

    // >0x9    bytele    2f    \b.%c file
    off = pageOff + 9
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (int64(int8(iv)) > 0x2f)
    }
    if m1 {
      out = append(out, "\\b.%c file")
    }

  }
  // 0x0    longle    4c    
  off = pageOff + 0
  {
    iv, ok := readUint32le(tb, off)
    m0 = ok && (uint64(iv) == 0x4c)
  }

  if m0 {
    // >0x4    longle    21401    Windows shortcut file
    off = pageOff + 4
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) == 0x21401)
    }
    if m1 {
      out = append(out, "Windows shortcut file")
    }

  }
  // 0x171    string    "MICROSOFT PIFEX\x00"    Windows Program Information File
  off = pageOff + 369
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Windows Program Information File")
  }

  if m0 {
    // >0x24    string    ">\x00"    \b for %.63s
    off = pageOff + 36
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b for %.63s")
    }

    // >0x65    string    ">\x00"    \b, directory=%.64s
    off = pageOff + 101
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, directory=%.64s")
    }

    // >0xa5    string    ">\x00"    \b, parameters=%.64s
    off = pageOff + 165
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, parameters=%.64s")
    }

    // >0x187    search/0xb55    "WINDOWS VMM 4.0\x00"    
    off = pageOff + 391
    // uh oh unhandled kind

    if m1 {
      // >>&0x5e    ubytele    0    
      off = pageOff + 94
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (int64(int8(iv)) > 0x0)
      }

      if m2 {
        // >>>&0x-1    string    "<PIFMGR.DLL"    \b, icon=%s
        off = pageOff + -1
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, icon=%s")
        }

        // >>>&0x-1    string    ">PIFMGR.DLL"    \b, icon=%s
        off = pageOff + -1
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, icon=%s")
        }

      }
      // >>&0xf0    ubytele    0    
      off = pageOff + 240
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (int64(int8(iv)) > 0x0)
      }

      if m2 {
        // >>>&0x-1    string    "<Terminal"    \b, font=%.32s
        off = pageOff + -1
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, font=%.32s")
        }

        // >>>&0x-1    string    ">Terminal"    \b, font=%.32s
        off = pageOff + -1
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, font=%.32s")
        }

      }
      // >>&0x110    ubytele    0    
      off = pageOff + 272
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (int64(int8(iv)) > 0x0)
      }

      if m2 {
        // >>>&0x-1    string    "<Lucida Console"    \b, TrueTypeFont=%.32s
        off = pageOff + -1
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, TrueTypeFont=%.32s")
        }

        // >>>&0x-1    string    ">Lucida Console"    \b, TrueTypeFont=%.32s
        off = pageOff + -1
        // uh oh unhandled kind
        if m3 {
          out = append(out, "\\b, TrueTypeFont=%.32s")
        }

      }
    }
    // >0x187    search/0xb55    "WINDOWS NT  3.1\x00"    \b, Windows NT-style
    off = pageOff + 391
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, Windows NT-style")
    }

    // >0x187    search/0xb55    "CONFIG  SYS 4.0\x00"    \b +CONFIG.SYS
    off = pageOff + 391
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b +CONFIG.SYS")
    }

    // >0x187    search/0xb55    "AUTOEXECBAT 4.0\x00"    \b +AUTOEXEC.BAT
    off = pageOff + 391
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b +AUTOEXEC.BAT")
    }

  }
  // 0x0    longbe    c5d0d3c6    DOS EPS Binary File
  off = pageOff + 0
  {
    iv, ok := readUint32be(tb, off)
    m0 = ok && (uint64(iv) == 0xc5d0d3c6)
  }
  if m0 {
    out = append(out, "DOS EPS Binary File")
  }

  if m0 {
    // >0x4    longle    0    Postscript starts at byte %d
    off = pageOff + 4
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (int64(int32(iv)) > 0x0)
    }
    if m1 {
      out = append(out, "Postscript starts at byte %d")
    }

    if m1 {
      // >>0x8    longle    0    length %d
      off = pageOff + 8
      {
        iv, ok := readUint32le(tb, off)
        m2 = ok && (int64(int32(iv)) > 0x0)
      }
      if m2 {
        out = append(out, "length %d")
      }

      if m2 {
        // >>>0xc    longle    0    Metafile starts at byte %d
        off = pageOff + 12
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (int64(int32(iv)) > 0x0)
        }
        if m3 {
          out = append(out, "Metafile starts at byte %d")
        }

        if m3 {
          // >>>>0x10    longle    0    length %d
          off = pageOff + 16
          {
            iv, ok := readUint32le(tb, off)
            m4 = ok && (int64(int32(iv)) > 0x0)
          }
          if m4 {
            out = append(out, "length %d")
          }

        }
        // >>>0x14    longle    0    TIFF starts at byte %d
        off = pageOff + 20
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (int64(int32(iv)) > 0x0)
        }
        if m3 {
          out = append(out, "TIFF starts at byte %d")
        }

        if m3 {
          // >>>>0x18    longle    0    length %d
          off = pageOff + 24
          {
            iv, ok := readUint32le(tb, off)
            m4 = ok && (int64(int32(iv)) > 0x0)
          }
          if m4 {
            out = append(out, "length %d")
          }

        }
      }
    }
  }
  // 0x0    shortle    223e9f78    TNEF
  off = pageOff + 0
  {
    iv, ok := readUint16le(tb, off)
    m0 = ok && (uint64(iv) == 0x223e9f78)
  }
  if m0 {
    out = append(out, "TNEF")
  }

  // 0x0    string    "NG\x00\x01"    
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0x2    ulongle    100    Norton Guide
    off = pageOff + 2
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) == 0x100)
    }
    if m1 {
      out = append(out, "Norton Guide")
    }

    if m1 {
      // >>0x8    string    ">\x00"    "%-.40s"
      off = pageOff + 8
      // uh oh unhandled kind
      if m2 {
        out = append(out, "\"%-.40s\"")
      }

      // >>0x30    string    ">\x00"    \b, %-.66s
      off = pageOff + 48
      // uh oh unhandled kind
      if m2 {
        out = append(out, "\\b, %-.66s")
      }

      // >>0x72    string    ">\x00"    %-.66s
      off = pageOff + 114
      // uh oh unhandled kind
      if m2 {
        out = append(out, "%-.66s")
      }

    }
  }
  // 0x0    ulongle    48443408    4DOS help file
  off = pageOff + 0
  {
    iv, ok := readUint32le(tb, off)
    m0 = ok && (uint64(iv) == 0x48443408)
  }
  if m0 {
    out = append(out, "4DOS help file")
  }

  if m0 {
    // >0x4    string    "x"    \b, version %-4.4s
    off = pageOff + 4
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, version %-4.4s")
    }

  }
  // 0x0    uquadle    3a000000024e4c    MS Advisor help file
  off = pageOff + 0
  {
    iv, ok := readUint64le(tb, off)
    m0 = ok && (uint64(iv) == 0x3a000000024e4c)
  }
  if m0 {
    out = append(out, "MS Advisor help file")
  }

  // 0x0    string    "ITSF\x03\x00\x00\x00`\x00\x00\x00"    MS Windows HtmlHelp Data
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "MS Windows HtmlHelp Data")
  }

  // 0x2    string    "GFA-BASIC3"    GFA-BASIC 3 data
  off = pageOff + 2
  // uh oh unhandled kind
  if m0 {
    out = append(out, "GFA-BASIC 3 data")
  }

  // 0x0    string    "MSCF\x00\x00\x00\x00"    Microsoft Cabinet archive data
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Microsoft Cabinet archive data")
  }

  if m0 {
    // >0x8    longle    0    \b, %u bytes
    off = pageOff + 8
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      out = append(out, "\\b, %u bytes")
    }

    // >0x1c    shortle    1    \b, 1 file
    off = pageOff + 28
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x1)
    }
    if m1 {
      out = append(out, "\\b, 1 file")
    }

    // >0x1c    shortle    1    \b, %u files
    off = pageOff + 28
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (int64(int16(iv)) > 0x1)
    }
    if m1 {
      out = append(out, "\\b, %u files")
    }

  }
  // 0x0    string    "ISc("    InstallShield Cabinet archive data
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "InstallShield Cabinet archive data")
  }

  if m0 {
    // >0x5    bytele    60&0xf0    version 6,
    off = pageOff + 5
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) == 0x60)
    }
    if m1 {
      out = append(out, "version 6,")
    }

    // >0x5    bytele    60&0xf0    version 4/5,
    off = pageOff + 5
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) != 0x60)
    }
    if m1 {
      out = append(out, "version 4/5,")
    }

    // >(0xc.longle+40)    longle    0    %u files
    // uh oh indirect offset
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      out = append(out, "%u files")
    }

  }
  // 0x0    string    "MSCE\x00\x00\x00\x00"    Microsoft WinCE install header
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Microsoft WinCE install header")
  }

  if m0 {
    // >0x14    longle    0    \b, architecture-independent
    off = pageOff + 20
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      out = append(out, "\\b, architecture-independent")
    }

    // >0x14    longle    67    \b, Hitachi SH3
    off = pageOff + 20
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) == 0x67)
    }
    if m1 {
      out = append(out, "\\b, Hitachi SH3")
    }

    // >0x14    longle    68    \b, Hitachi SH4
    off = pageOff + 20
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) == 0x68)
    }
    if m1 {
      out = append(out, "\\b, Hitachi SH4")
    }

    // >0x14    longle    a11    \b, StrongARM
    off = pageOff + 20
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) == 0xa11)
    }
    if m1 {
      out = append(out, "\\b, StrongARM")
    }

    // >0x14    longle    fa0    \b, MIPS R4000
    off = pageOff + 20
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) == 0xfa0)
    }
    if m1 {
      out = append(out, "\\b, MIPS R4000")
    }

    // >0x14    longle    2713    \b, Hitachi SH3
    off = pageOff + 20
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) == 0x2713)
    }
    if m1 {
      out = append(out, "\\b, Hitachi SH3")
    }

    // >0x14    longle    2714    \b, Hitachi SH3E
    off = pageOff + 20
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) == 0x2714)
    }
    if m1 {
      out = append(out, "\\b, Hitachi SH3E")
    }

    // >0x14    longle    2715    \b, Hitachi SH4
    off = pageOff + 20
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) == 0x2715)
    }
    if m1 {
      out = append(out, "\\b, Hitachi SH4")
    }

    // >0x14    longle    11171    \b, ARM 7TDMI
    off = pageOff + 20
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) == 0x11171)
    }
    if m1 {
      out = append(out, "\\b, ARM 7TDMI")
    }

    // >0x34    shortle    1    \b, 1 file
    off = pageOff + 52
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x1)
    }
    if m1 {
      out = append(out, "\\b, 1 file")
    }

    // >0x34    shortle    1    \b, %u files
    off = pageOff + 52
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (int64(int16(iv)) > 0x1)
    }
    if m1 {
      out = append(out, "\\b, %u files")
    }

    // >0x38    shortle    1    \b, 1 registry entry
    off = pageOff + 56
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x1)
    }
    if m1 {
      out = append(out, "\\b, 1 registry entry")
    }

    // >0x38    shortle    1    \b, %u registry entries
    off = pageOff + 56
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (int64(int16(iv)) > 0x1)
    }
    if m1 {
      out = append(out, "\\b, %u registry entries")
    }

  }
  // 0x0    ulongle    1    
  off = pageOff + 0
  {
    iv, ok := readUint32le(tb, off)
    m0 = ok && (uint64(iv) == 0x1)
  }

  if m0 {
    // >0x28    string    " EMF"    Windows Enhanced Metafile (EMF) image data
    off = pageOff + 40
    // uh oh unhandled kind
    if m1 {
      out = append(out, "Windows Enhanced Metafile (EMF) image data")
    }

    if m1 {
      // >>0x2c    ulongle    0    version 0x%x
      off = pageOff + 44
      {
        iv, ok := readUint32le(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }
      if m2 {
        out = append(out, "version 0x%x")
      }

    }
  }
  // 0x0    string    "\xd0\xcf\x11\u0871\x1a\xe1"    Microsoft Office Document
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Microsoft Office Document")
  }

  if m0 {
    // >0x222    string    "bjbj"    Microsoft Word Document
    off = pageOff + 546
    // uh oh unhandled kind
    if m1 {
      out = append(out, "Microsoft Word Document")
    }

    // >0x222    string    "jbjb"    Microsoft Word Document
    off = pageOff + 546
    // uh oh unhandled kind
    if m1 {
      out = append(out, "Microsoft Word Document")
    }

  }
  // 0x0    string    "\x94\xa6."    Microsoft Word Document
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Microsoft Word Document")
  }

  // 0x200    string    "R\x00o\x00o\x00t\x00 \x00E\x00n\x00t\x00r\x00y"    Microsoft Word Document
  off = pageOff + 512
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Microsoft Word Document")
  }

  // 0x0    string    "$RBU"    
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0x17    string    "Dell"    %s system BIOS
    off = pageOff + 23
    // uh oh unhandled kind
    if m1 {
      out = append(out, "%s system BIOS")
    }

    // >0x5    bytele    2    
    off = pageOff + 5
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) == 0x2)
    }

    if m1 {
      // >>0x30    bytele    0    version %d.
      off = pageOff + 48
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }
      if m2 {
        out = append(out, "version %d.")
      }

      // >>0x31    bytele    0    \b%d.
      off = pageOff + 49
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }
      if m2 {
        out = append(out, "\\b%d.")
      }

      // >>0x32    bytele    0    \b%d
      off = pageOff + 50
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }
      if m2 {
        out = append(out, "\\b%d")
      }

    }
    // >0x5    bytele    2    
    off = pageOff + 5
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (int64(int8(iv)) < 0x2)
    }

    if m1 {
      // >>0x30    string    "x"    version %.3s
      off = pageOff + 48
      // uh oh unhandled kind
      if m2 {
        out = append(out, "version %.3s")
      }

    }
  }
  // 0x0    string    "DDS |\x00\x00\x00"    Microsoft DirectDraw Surface (DDS),
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Microsoft DirectDraw Surface (DDS),")
  }

  if m0 {
    // >0x10    longle    0    %d x
    off = pageOff + 16
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (int64(int32(iv)) > 0x0)
    }
    if m1 {
      out = append(out, "%d x")
    }

    // >0xc    longle    0    %d,
    off = pageOff + 12
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (int64(int32(iv)) > 0x0)
    }
    if m1 {
      out = append(out, "%d,")
    }

    // >0x54    string    "x"    %.4s
    off = pageOff + 84
    // uh oh unhandled kind
    if m1 {
      out = append(out, "%.4s")
    }

  }
  // 0x0    string    "ITOLITLS"    Microsoft Reader eBook Data
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Microsoft Reader eBook Data")
  }

  if m0 {
    // >0x8    longle    0    \b, version %u
    off = pageOff + 8
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      out = append(out, "\\b, version %u")
    }

  }
  // 0x0    string    "B000FF\n"    Windows Embedded CE binary image
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Windows Embedded CE binary image")
  }

  // 0x0    string    "MSWIM\x00\x00\x00"    Windows imaging (WIM) image
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Windows imaging (WIM) image")
  }

  // 0x0    string    "WLPWM\x00\x00\x00"    Windows imaging (WIM) image, wimlib pipable format
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Windows imaging (WIM) image, wimlib pipable format")
  }

  // 0x0    string    "\xfc\x03\x00"    Mallard BASIC program data (v1.11)
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Mallard BASIC program data (v1.11)")
  }

  // 0x0    string    "\xfc\x04\x00"    Mallard BASIC program data (v1.29+)
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Mallard BASIC program data (v1.29+)")
  }

  // 0x0    string    "\xfc\x03\x01"    Mallard BASIC protected program data (v1.11)
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Mallard BASIC protected program data (v1.11)")
  }

  // 0x0    string    "\xfc\x04\x01"    Mallard BASIC protected program data (v1.29+)
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Mallard BASIC protected program data (v1.29+)")
  }

  // 0x0    string    "MIOPEN"    Mallard BASIC Jetsam data
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Mallard BASIC Jetsam data")
  }

  // 0x0    string    "Jetsam0"    Mallard BASIC Jetsam index data
  off = pageOff + 0
  // uh oh unhandled kind
  if m0 {
    out = append(out, "Mallard BASIC Jetsam index data")
  }

  // 0x3    ushortle    7bb    
  off = pageOff + 3
  {
    iv, ok := readUint16le(tb, off)
    m0 = ok && (int64(int16(iv)) > 0x7bb)
  }

  if m0 {
    // >0x5    ubytele    1f    
    off = pageOff + 5
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (int64(int8(iv)) < 0x1f)
    }

    if m1 {
      // >>0x6    ubytele    c    
      off = pageOff + 6
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (int64(int8(iv)) < 0xc)
      }

      if m2 {
        // >>>0x7    string    "\x00\x00\x00\x00\x00\x00\x00\x00"    
        off = pageOff + 7
        // uh oh unhandled kind

        if m3 {
          // >>>>0x1    ubytele    0    DOS 2.0 backup id file, sequence %d
          off = pageOff + 1
          {
            iv, ok := readUint8le(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }
          if m4 {
            out = append(out, "DOS 2.0 backup id file, sequence %d")
          }

          // >>>>0x0    ubytele    ff    \b, last disk
          off = pageOff + 0
          {
            iv, ok := readUint8le(tb, off)
            m4 = ok && (uint64(iv) == 0xff)
          }
          if m4 {
            out = append(out, "\\b, last disk")
          }

        }
      }
    }
  }
  // 0x53    ubytele    50    
  off = pageOff + 83
  {
    iv, ok := readUint8le(tb, off)
    m0 = ok && (int64(int8(iv)) < 0x50)
  }

  if m0 {
    // >0x54    string    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"    
    off = pageOff + 84
    // uh oh unhandled kind

    if m1 {
      // >>0x5    string    "x"    DOS 2.0 backed up file %s,
      off = pageOff + 5
      // uh oh unhandled kind
      if m2 {
        out = append(out, "DOS 2.0 backed up file %s,")
      }

      // >>0x0    ubytele    ff    complete file
      off = pageOff + 0
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0xff)
      }
      if m2 {
        out = append(out, "complete file")
      }

      // >>0x0    ubytele    ff    
      off = pageOff + 0
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) != 0xff)
      }

      if m2 {
        // >>>0x1    ushortle    0    split file, sequence %d
        off = pageOff + 1
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x0)
        }
        if m3 {
          out = append(out, "split file, sequence %d")
        }

      }
    }
  }
  // 0x0    string    "\x8bBACKUP "    
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0xa    string    "\x00\x00\x00\x00\x00\x00\x00\x00"    
    off = pageOff + 10
    // uh oh unhandled kind

    if m1 {
      // >>0x9    ubytele    0    DOS 3.3 backup control file, sequence %d
      off = pageOff + 9
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }
      if m2 {
        out = append(out, "DOS 3.3 backup control file, sequence %d")
      }

      // >>0x8a    ubytele    ff    \b, last disk
      off = pageOff + 138
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0xff)
      }
      if m2 {
        out = append(out, "\\b, last disk")
      }

    }
  }
  return out, nil
}

func IdentifyMsdosDriver__Swapped(tb []byte, pageOff int64) ([]string, error) {
  var out []string
  var off int64
  m0 := false
  m1 := false
  m2 := false
  m3 := false
  m4 := false
  m5 := false
  m6 := false

  if m0 {
    // >0x28    search/0x7    "UPX!"    \bUPX compressed
    off = pageOff + 40
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\bUPX compressed")
    }

    // >0x4    ushortle    0&0x8000    \bblock device driver
    off = pageOff + 4
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      out = append(out, "\\bblock device driver")
    }

    // >0x4    ushortle    8000&0x8000    \b
    off = pageOff + 4
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x8000)
    }
    if m1 {
      out = append(out, "\\b")
    }

    if m1 {
      // >>0x4    ushortle    8&0x8    \bclock
      off = pageOff + 4
      {
        iv, ok := readUint16le(tb, off)
        m2 = ok && (uint64(iv) == 0x8)
      }
      if m2 {
        out = append(out, "\\bclock")
      }

      // >>0x4    ushortle    10&0x10    \bfast
      off = pageOff + 4
      {
        iv, ok := readUint16le(tb, off)
        m2 = ok && (uint64(iv) == 0x10)
      }
      if m2 {
        out = append(out, "\\bfast")
      }

      // >>0x4    ushortle    0&0x3    \bstandard
      off = pageOff + 4
      {
        iv, ok := readUint16le(tb, off)
        m2 = ok && (int64(int16(iv)) > 0x0)
      }
      if m2 {
        out = append(out, "\\bstandard")
      }

      if m2 {
        // >>>0x4    ushortle    1&0x1    \binput
        off = pageOff + 4
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x1)
        }
        if m3 {
          out = append(out, "\\binput")
        }

        // >>>0x4    ushortle    3&0x3    \b/
        off = pageOff + 4
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x3)
        }
        if m3 {
          out = append(out, "\\b/")
        }

        // >>>0x4    ushortle    2&0x2    \boutput
        off = pageOff + 4
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x2)
        }
        if m3 {
          out = append(out, "\\boutput")
        }

      }
      // >>0x4    ushortle    8000&0x8000    \bcharacter device driver
      off = pageOff + 4
      {
        iv, ok := readUint16le(tb, off)
        m2 = ok && (uint64(iv) == 0x8000)
      }
      if m2 {
        out = append(out, "\\bcharacter device driver")
      }

    }
    // >0x0    ubytele    0    
    off = pageOff + 0
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }

    if m1 {
      // >>0x28    search/0x7    "UPX!"    
      off = pageOff + 40
      // uh oh unhandled kind

      // >>0x28    default    
      off = pageOff + 40
      // uh oh unhandled kind

      if m2 {
        // >>>0xc    ubytele    2e    \b
        off = pageOff + 12
        {
          iv, ok := readUint8le(tb, off)
          m3 = ok && (int64(int8(iv)) > 0x2e)
        }
        if m3 {
          out = append(out, "\\b")
        }

        if m3 {
          // >>>>0xa    ubytele    20    
          off = pageOff + 10
          {
            iv, ok := readUint8le(tb, off)
            m4 = ok && (int64(int8(iv)) > 0x20)
          }

          if m4 {
            // >>>>>0xa    ubytele    2e    
            off = pageOff + 10
            {
              iv, ok := readUint8le(tb, off)
              m5 = ok && (uint64(iv) != 0x2e)
            }

            if m5 {
              // >>>>>>0xa    ubytele    2a    \b%c
              off = pageOff + 10
              {
                iv, ok := readUint8le(tb, off)
                m6 = ok && (uint64(iv) != 0x2a)
              }
              if m6 {
                out = append(out, "\\b%c")
              }

            }
          }
          // >>>>0xb    ubytele    20    
          off = pageOff + 11
          {
            iv, ok := readUint8le(tb, off)
            m4 = ok && (int64(int8(iv)) > 0x20)
          }

          if m4 {
            // >>>>>0xb    ubytele    2e    \b%c
            off = pageOff + 11
            {
              iv, ok := readUint8le(tb, off)
              m5 = ok && (uint64(iv) != 0x2e)
            }
            if m5 {
              out = append(out, "\\b%c")
            }

          }
          // >>>>0xc    ubytele    20    
          off = pageOff + 12
          {
            iv, ok := readUint8le(tb, off)
            m4 = ok && (int64(int8(iv)) > 0x20)
          }

          if m4 {
            // >>>>>0xc    ubytele    39    
            off = pageOff + 12
            {
              iv, ok := readUint8le(tb, off)
              m5 = ok && (uint64(iv) != 0x39)
            }

            if m5 {
              // >>>>>>0xc    ubytele    2e    \b%c
              off = pageOff + 12
              {
                iv, ok := readUint8le(tb, off)
                m6 = ok && (uint64(iv) != 0x2e)
              }
              if m6 {
                out = append(out, "\\b%c")
              }

            }
          }
        }
        // >>>0xd    ubytele    20    
        off = pageOff + 13
        {
          iv, ok := readUint8le(tb, off)
          m3 = ok && (int64(int8(iv)) > 0x20)
        }

        if m3 {
          // >>>>0xd    ubytele    2e    \b%c
          off = pageOff + 13
          {
            iv, ok := readUint8le(tb, off)
            m4 = ok && (uint64(iv) != 0x2e)
          }
          if m4 {
            out = append(out, "\\b%c")
          }

          // >>>>0xe    ubytele    20    
          off = pageOff + 14
          {
            iv, ok := readUint8le(tb, off)
            m4 = ok && (int64(int8(iv)) > 0x20)
          }

          if m4 {
            // >>>>>0xe    ubytele    2e    \b%c
            off = pageOff + 14
            {
              iv, ok := readUint8le(tb, off)
              m5 = ok && (uint64(iv) != 0x2e)
            }
            if m5 {
              out = append(out, "\\b%c")
            }

          }
          // >>>>0xf    ubytele    20    
          off = pageOff + 15
          {
            iv, ok := readUint8le(tb, off)
            m4 = ok && (int64(int8(iv)) > 0x20)
          }

          if m4 {
            // >>>>>0xf    ubytele    2e    \b%c
            off = pageOff + 15
            {
              iv, ok := readUint8le(tb, off)
              m5 = ok && (uint64(iv) != 0x2e)
            }
            if m5 {
              out = append(out, "\\b%c")
            }

          }
          // >>>>0x10    ubytele    20    
          off = pageOff + 16
          {
            iv, ok := readUint8le(tb, off)
            m4 = ok && (int64(int8(iv)) > 0x20)
          }

          if m4 {
            // >>>>>0x10    ubytele    2e    
            off = pageOff + 16
            {
              iv, ok := readUint8le(tb, off)
              m5 = ok && (uint64(iv) != 0x2e)
            }

            if m5 {
              // >>>>>>0x10    ubytele    cb    \b%c
              off = pageOff + 16
              {
                iv, ok := readUint8le(tb, off)
                m6 = ok && (int64(int8(iv)) < 0xcb)
              }
              if m6 {
                out = append(out, "\\b%c")
              }

            }
          }
          // >>>>0x11    ubytele    20    
          off = pageOff + 17
          {
            iv, ok := readUint8le(tb, off)
            m4 = ok && (int64(int8(iv)) > 0x20)
          }

          if m4 {
            // >>>>>0x11    ubytele    2e    
            off = pageOff + 17
            {
              iv, ok := readUint8le(tb, off)
              m5 = ok && (uint64(iv) != 0x2e)
            }

            if m5 {
              // >>>>>>0x11    ubytele    90    \b%c
              off = pageOff + 17
              {
                iv, ok := readUint8le(tb, off)
                m6 = ok && (int64(int8(iv)) < 0x90)
              }
              if m6 {
                out = append(out, "\\b%c")
              }

            }
          }
        }
        // >>>0xc    ubytele    2f    
        off = pageOff + 12
        {
          iv, ok := readUint8le(tb, off)
          m3 = ok && (int64(int8(iv)) < 0x2f)
        }

        if m3 {
          // >>>>0x16    string    ">."    %-.6s
          off = pageOff + 22
          // uh oh unhandled kind
          if m4 {
            out = append(out, "%-.6s")
          }

        }
      }
    }
    // >0x4    ushortle    0&0x8000    
    off = pageOff + 4
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }

    if m1 {
      // >>0x4    ushortle    2&0x2    \b,32-bit sector-
      off = pageOff + 4
      {
        iv, ok := readUint16le(tb, off)
        m2 = ok && (uint64(iv) == 0x2)
      }
      if m2 {
        out = append(out, "\\b,32-bit sector-")
      }

    }
    // >0x4    ushortle    40&0x40    \b,IOCTL-
    off = pageOff + 4
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x40)
    }
    if m1 {
      out = append(out, "\\b,IOCTL-")
    }

    // >0x4    ushortle    800&0x800    \b,close media-
    off = pageOff + 4
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x800)
    }
    if m1 {
      out = append(out, "\\b,close media-")
    }

    // >0x4    ushortle    8000&0x8000    
    off = pageOff + 4
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x8000)
    }

    if m1 {
      // >>0x4    ushortle    2000&0x2000    \b,until busy-
      off = pageOff + 4
      {
        iv, ok := readUint16le(tb, off)
        m2 = ok && (uint64(iv) == 0x2000)
      }
      if m2 {
        out = append(out, "\\b,until busy-")
      }

    }
    // >0x4    ushortle    4000&0x4000    \b,control strings-
    off = pageOff + 4
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x4000)
    }
    if m1 {
      out = append(out, "\\b,control strings-")
    }

    // >0x4    ushortle    8000&0x8000    
    off = pageOff + 4
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x8000)
    }

    if m1 {
      // >>0x4    ushortle    0&0x6840    \bsupport
      off = pageOff + 4
      {
        iv, ok := readUint16le(tb, off)
        m2 = ok && (int64(int16(iv)) > 0x0)
      }
      if m2 {
        out = append(out, "\\bsupport")
      }

    }
    // >0x4    ushortle    0&0x8000    
    off = pageOff + 4
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }

    if m1 {
      // >>0x4    ushortle    0&0x4842    \bsupport
      off = pageOff + 4
      {
        iv, ok := readUint16le(tb, off)
        m2 = ok && (int64(int16(iv)) > 0x0)
      }
      if m2 {
        out = append(out, "\\bsupport")
      }

    }
    // >0x0    ubytele    0    \b)
    off = pageOff + 0
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      out = append(out, "\\b)")
    }

  }
  return out, nil
}

func IdentifyMsdosCom__Swapped(tb []byte, pageOff int64) ([]string, error) {
  var out []string
  var off int64
  m0 := false
  m1 := false

  if m0 {
    // >0x0    bytele    0    DOS executable (COM)
    off = pageOff + 0
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      out = append(out, "DOS executable (COM)")
    }

    // >0x6    string    "SFX of LHarc"    \b, %s
    off = pageOff + 6
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, %s")
    }

    // >0x1fe    shortle    aa55    \b, boot code
    off = pageOff + 510
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xaa55)
    }
    if m1 {
      out = append(out, "\\b, boot code")
    }

    // >0x55    string    "UPX"    \b, UPX compressed
    off = pageOff + 85
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, UPX compressed")
    }

    // >0x4    string    " $ARX"    \b, ARX self-extracting archive
    off = pageOff + 4
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, ARX self-extracting archive")
    }

    // >0x4    string    " $LHarc"    \b, LHarc self-extracting archive
    off = pageOff + 4
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, LHarc self-extracting archive")
    }

    // >0x20e    string    "SFX by LARC"    \b, LARC self-extracting archive
    off = pageOff + 526
    // uh oh unhandled kind
    if m1 {
      out = append(out, "\\b, LARC self-extracting archive")
    }

  }
  return out, nil
}

func IdentifyElfLe__Swapped(tb []byte, pageOff int64) ([]string, error) {
  var out []string
  var off int64
  m0 := false
  m1 := false
  m2 := false
  m3 := false

  if m0 {
    // >0x10    shortle    0    no file type,
    off = pageOff + 16
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      out = append(out, "no file type,")
    }

    // >0x10    shortle    1    relocatable,
    off = pageOff + 16
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x1)
    }
    if m1 {
      out = append(out, "relocatable,")
    }

    // >0x10    shortle    2    executable,
    off = pageOff + 16
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x2)
    }
    if m1 {
      out = append(out, "executable,")
    }

    // >0x10    shortle    3    shared object,
    off = pageOff + 16
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x3)
    }
    if m1 {
      out = append(out, "shared object,")
    }

    // >0x10    shortle    4    core file
    off = pageOff + 16
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x4)
    }
    if m1 {
      out = append(out, "core file")
    }

    // >0x12    clear    
    off = pageOff + 18
    // uh oh unhandled kind

    // >0x12    shortle    0    no machine,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      out = append(out, "no machine,")
    }

    // >0x12    shortle    1    AT&T WE32100,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x1)
    }
    if m1 {
      out = append(out, "AT&T WE32100,")
    }

    // >0x12    shortle    2    SPARC,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x2)
    }
    if m1 {
      out = append(out, "SPARC,")
    }

    // >0x12    shortle    3    Intel 80386,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x3)
    }
    if m1 {
      out = append(out, "Intel 80386,")
    }

    // >0x12    shortle    4    Motorola m68k,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x4)
    }
    if m1 {
      out = append(out, "Motorola m68k,")
    }

    if m1 {
      // >>0x4    bytele    1    
      off = pageOff + 4
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x1)
      }

      if m2 {
        // >>>0x24    longle    0    68020,
        off = pageOff + 36
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x0)
        }
        if m3 {
          out = append(out, "68020,")
        }

      }
    }
    // >0x12    shortle    5    Motorola m88k,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x5)
    }
    if m1 {
      out = append(out, "Motorola m88k,")
    }

    // >0x12    shortle    6    Intel 80486,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x6)
    }
    if m1 {
      out = append(out, "Intel 80486,")
    }

    // >0x12    shortle    7    Intel 80860,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x7)
    }
    if m1 {
      out = append(out, "Intel 80860,")
    }

    // >0x12    shortle    8    MIPS,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x8)
    }
    if m1 {
      out = append(out, "MIPS,")
    }

    if m1 {
      // >>0x4    bytele    1    
      off = pageOff + 4
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x1)
      }

    }
    // >0x12    shortle    a    MIPS,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xa)
    }
    if m1 {
      out = append(out, "MIPS,")
    }

    if m1 {
      // >>0x4    bytele    1    
      off = pageOff + 4
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x1)
      }

    }
    // >0x12    shortle    8    
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x8)
    }

    if m1 {
      // >>0x4    bytele    1    
      off = pageOff + 4
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x1)
      }

      if m2 {
        // >>>0x24    longle    0&0xf0000000    MIPS-I
        off = pageOff + 36
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x0)
        }
        if m3 {
          out = append(out, "MIPS-I")
        }

        // >>>0x24    longle    10000000&0xf0000000    MIPS-II
        off = pageOff + 36
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x10000000)
        }
        if m3 {
          out = append(out, "MIPS-II")
        }

        // >>>0x24    longle    20000000&0xf0000000    MIPS-III
        off = pageOff + 36
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x20000000)
        }
        if m3 {
          out = append(out, "MIPS-III")
        }

        // >>>0x24    longle    30000000&0xf0000000    MIPS-IV
        off = pageOff + 36
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x30000000)
        }
        if m3 {
          out = append(out, "MIPS-IV")
        }

        // >>>0x24    longle    40000000&0xf0000000    MIPS-V
        off = pageOff + 36
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x40000000)
        }
        if m3 {
          out = append(out, "MIPS-V")
        }

        // >>>0x24    longle    50000000&0xf0000000    MIPS32
        off = pageOff + 36
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x50000000)
        }
        if m3 {
          out = append(out, "MIPS32")
        }

        // >>>0x24    longle    60000000&0xf0000000    MIPS64
        off = pageOff + 36
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x60000000)
        }
        if m3 {
          out = append(out, "MIPS64")
        }

        // >>>0x24    longle    70000000&0xf0000000    MIPS32 rel2
        off = pageOff + 36
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x70000000)
        }
        if m3 {
          out = append(out, "MIPS32 rel2")
        }

        // >>>0x24    longle    80000000&0xf0000000    MIPS64 rel2
        off = pageOff + 36
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x80000000)
        }
        if m3 {
          out = append(out, "MIPS64 rel2")
        }

      }
      // >>0x4    bytele    2    
      off = pageOff + 4
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x2)
      }

      if m2 {
        // >>>0x30    longle    0&0xf0000000    MIPS-I
        off = pageOff + 48
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x0)
        }
        if m3 {
          out = append(out, "MIPS-I")
        }

        // >>>0x30    longle    10000000&0xf0000000    MIPS-II
        off = pageOff + 48
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x10000000)
        }
        if m3 {
          out = append(out, "MIPS-II")
        }

        // >>>0x30    longle    20000000&0xf0000000    MIPS-III
        off = pageOff + 48
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x20000000)
        }
        if m3 {
          out = append(out, "MIPS-III")
        }

        // >>>0x30    longle    30000000&0xf0000000    MIPS-IV
        off = pageOff + 48
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x30000000)
        }
        if m3 {
          out = append(out, "MIPS-IV")
        }

        // >>>0x30    longle    40000000&0xf0000000    MIPS-V
        off = pageOff + 48
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x40000000)
        }
        if m3 {
          out = append(out, "MIPS-V")
        }

        // >>>0x30    longle    50000000&0xf0000000    MIPS32
        off = pageOff + 48
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x50000000)
        }
        if m3 {
          out = append(out, "MIPS32")
        }

        // >>>0x30    longle    60000000&0xf0000000    MIPS64
        off = pageOff + 48
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x60000000)
        }
        if m3 {
          out = append(out, "MIPS64")
        }

        // >>>0x30    longle    70000000&0xf0000000    MIPS32 rel2
        off = pageOff + 48
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x70000000)
        }
        if m3 {
          out = append(out, "MIPS32 rel2")
        }

        // >>>0x30    longle    80000000&0xf0000000    MIPS64 rel2
        off = pageOff + 48
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x80000000)
        }
        if m3 {
          out = append(out, "MIPS64 rel2")
        }

      }
    }
    // >0x12    shortle    9    Amdahl,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x9)
    }
    if m1 {
      out = append(out, "Amdahl,")
    }

    // >0x12    shortle    a    MIPS (deprecated),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xa)
    }
    if m1 {
      out = append(out, "MIPS (deprecated),")
    }

    // >0x12    shortle    b    RS6000,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xb)
    }
    if m1 {
      out = append(out, "RS6000,")
    }

    // >0x12    shortle    f    PA-RISC,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xf)
    }
    if m1 {
      out = append(out, "PA-RISC,")
    }

    if m1 {
      // >>0x4    bytele    1    
      off = pageOff + 4
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x1)
      }

      if m2 {
        // >>>0x26    shortle    214    2.0
        off = pageOff + 38
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x214)
        }
        if m3 {
          out = append(out, "2.0")
        }

      }
      // >>0x4    bytele    2    
      off = pageOff + 4
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x2)
      }

      if m2 {
        // >>>0x32    shortle    214    2.0
        off = pageOff + 50
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x214)
        }
        if m3 {
          out = append(out, "2.0")
        }

      }
    }
    // >0x12    shortle    10    nCUBE,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x10)
    }
    if m1 {
      out = append(out, "nCUBE,")
    }

    // >0x12    shortle    11    Fujitsu VPP500,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x11)
    }
    if m1 {
      out = append(out, "Fujitsu VPP500,")
    }

    // >0x12    shortle    12    SPARC32PLUS,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x12)
    }
    if m1 {
      out = append(out, "SPARC32PLUS,")
    }

    if m1 {
      // >>0x4    bytele    1    
      off = pageOff + 4
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x1)
      }

      if m2 {
        // >>>0x24    longle    100&0xffff00    V8+ Required,
        off = pageOff + 36
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x100)
        }
        if m3 {
          out = append(out, "V8+ Required,")
        }

        // >>>0x24    longle    200&0xffff00    Sun UltraSPARC1 Extensions Required,
        off = pageOff + 36
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x200)
        }
        if m3 {
          out = append(out, "Sun UltraSPARC1 Extensions Required,")
        }

        // >>>0x24    longle    400&0xffff00    HaL R1 Extensions Required,
        off = pageOff + 36
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x400)
        }
        if m3 {
          out = append(out, "HaL R1 Extensions Required,")
        }

        // >>>0x24    longle    800&0xffff00    Sun UltraSPARC3 Extensions Required,
        off = pageOff + 36
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x800)
        }
        if m3 {
          out = append(out, "Sun UltraSPARC3 Extensions Required,")
        }

      }
    }
    // >0x12    shortle    13    Intel 80960,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x13)
    }
    if m1 {
      out = append(out, "Intel 80960,")
    }

    // >0x12    shortle    14    PowerPC or cisco 4500,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x14)
    }
    if m1 {
      out = append(out, "PowerPC or cisco 4500,")
    }

    // >0x12    shortle    15    64-bit PowerPC or cisco 7500,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x15)
    }
    if m1 {
      out = append(out, "64-bit PowerPC or cisco 7500,")
    }

    // >0x12    shortle    16    IBM S/390,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x16)
    }
    if m1 {
      out = append(out, "IBM S/390,")
    }

    // >0x12    shortle    17    Cell SPU,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x17)
    }
    if m1 {
      out = append(out, "Cell SPU,")
    }

    // >0x12    shortle    18    cisco SVIP,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x18)
    }
    if m1 {
      out = append(out, "cisco SVIP,")
    }

    // >0x12    shortle    19    cisco 7200,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x19)
    }
    if m1 {
      out = append(out, "cisco 7200,")
    }

    // >0x12    shortle    24    NEC V800 or cisco 12000,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x24)
    }
    if m1 {
      out = append(out, "NEC V800 or cisco 12000,")
    }

    // >0x12    shortle    25    Fujitsu FR20,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x25)
    }
    if m1 {
      out = append(out, "Fujitsu FR20,")
    }

    // >0x12    shortle    26    TRW RH-32,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x26)
    }
    if m1 {
      out = append(out, "TRW RH-32,")
    }

    // >0x12    shortle    27    Motorola RCE,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x27)
    }
    if m1 {
      out = append(out, "Motorola RCE,")
    }

    // >0x12    shortle    28    ARM,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x28)
    }
    if m1 {
      out = append(out, "ARM,")
    }

    if m1 {
      // >>0x4    bytele    1    
      off = pageOff + 4
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x1)
      }

      if m2 {
        // >>>0x24    longle    4000000&0xff000000    EABI4
        off = pageOff + 36
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x4000000)
        }
        if m3 {
          out = append(out, "EABI4")
        }

        // >>>0x24    longle    5000000&0xff000000    EABI5
        off = pageOff + 36
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x5000000)
        }
        if m3 {
          out = append(out, "EABI5")
        }

      }
    }
    // >0x12    shortle    29    Alpha,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x29)
    }
    if m1 {
      out = append(out, "Alpha,")
    }

    // >0x12    shortle    2a    Renesas SH,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x2a)
    }
    if m1 {
      out = append(out, "Renesas SH,")
    }

    // >0x12    shortle    2b    SPARC V9,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x2b)
    }
    if m1 {
      out = append(out, "SPARC V9,")
    }

    if m1 {
      // >>0x4    bytele    2    
      off = pageOff + 4
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x2)
      }

      if m2 {
        // >>>0x30    longle    200&0xffff00    Sun UltraSPARC1 Extensions Required,
        off = pageOff + 48
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x200)
        }
        if m3 {
          out = append(out, "Sun UltraSPARC1 Extensions Required,")
        }

        // >>>0x30    longle    400&0xffff00    HaL R1 Extensions Required,
        off = pageOff + 48
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x400)
        }
        if m3 {
          out = append(out, "HaL R1 Extensions Required,")
        }

        // >>>0x30    longle    800&0xffff00    Sun UltraSPARC3 Extensions Required,
        off = pageOff + 48
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x800)
        }
        if m3 {
          out = append(out, "Sun UltraSPARC3 Extensions Required,")
        }

        // >>>0x30    longle    0&0x3    total store ordering,
        off = pageOff + 48
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x0)
        }
        if m3 {
          out = append(out, "total store ordering,")
        }

        // >>>0x30    longle    1&0x3    partial store ordering,
        off = pageOff + 48
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x1)
        }
        if m3 {
          out = append(out, "partial store ordering,")
        }

        // >>>0x30    longle    2&0x3    relaxed memory ordering,
        off = pageOff + 48
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x2)
        }
        if m3 {
          out = append(out, "relaxed memory ordering,")
        }

      }
    }
    // >0x12    shortle    2c    Siemens Tricore Embedded Processor,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x2c)
    }
    if m1 {
      out = append(out, "Siemens Tricore Embedded Processor,")
    }

    // >0x12    shortle    2d    Argonaut RISC Core, Argonaut Technologies Inc.,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x2d)
    }
    if m1 {
      out = append(out, "Argonaut RISC Core, Argonaut Technologies Inc.,")
    }

    // >0x12    shortle    2e    Renesas H8/300,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x2e)
    }
    if m1 {
      out = append(out, "Renesas H8/300,")
    }

    // >0x12    shortle    2f    Renesas H8/300H,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x2f)
    }
    if m1 {
      out = append(out, "Renesas H8/300H,")
    }

    // >0x12    shortle    30    Renesas H8S,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x30)
    }
    if m1 {
      out = append(out, "Renesas H8S,")
    }

    // >0x12    shortle    31    Renesas H8/500,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x31)
    }
    if m1 {
      out = append(out, "Renesas H8/500,")
    }

    // >0x12    shortle    32    IA-64,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x32)
    }
    if m1 {
      out = append(out, "IA-64,")
    }

    // >0x12    shortle    33    Stanford MIPS-X,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x33)
    }
    if m1 {
      out = append(out, "Stanford MIPS-X,")
    }

    // >0x12    shortle    34    Motorola Coldfire,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x34)
    }
    if m1 {
      out = append(out, "Motorola Coldfire,")
    }

    // >0x12    shortle    35    Motorola M68HC12,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x35)
    }
    if m1 {
      out = append(out, "Motorola M68HC12,")
    }

    // >0x12    shortle    36    Fujitsu MMA,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x36)
    }
    if m1 {
      out = append(out, "Fujitsu MMA,")
    }

    // >0x12    shortle    37    Siemens PCP,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x37)
    }
    if m1 {
      out = append(out, "Siemens PCP,")
    }

    // >0x12    shortle    38    Sony nCPU,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x38)
    }
    if m1 {
      out = append(out, "Sony nCPU,")
    }

    // >0x12    shortle    39    Denso NDR1,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x39)
    }
    if m1 {
      out = append(out, "Denso NDR1,")
    }

    // >0x12    shortle    3a    Start*Core,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x3a)
    }
    if m1 {
      out = append(out, "Start*Core,")
    }

    // >0x12    shortle    3b    Toyota ME16,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x3b)
    }
    if m1 {
      out = append(out, "Toyota ME16,")
    }

    // >0x12    shortle    3c    ST100,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x3c)
    }
    if m1 {
      out = append(out, "ST100,")
    }

    // >0x12    shortle    3d    Tinyj emb.,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x3d)
    }
    if m1 {
      out = append(out, "Tinyj emb.,")
    }

    // >0x12    shortle    3e    x86-64,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x3e)
    }
    if m1 {
      out = append(out, "x86-64,")
    }

    // >0x12    shortle    3f    Sony DSP,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x3f)
    }
    if m1 {
      out = append(out, "Sony DSP,")
    }

    // >0x12    shortle    40    DEC PDP-10,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x40)
    }
    if m1 {
      out = append(out, "DEC PDP-10,")
    }

    // >0x12    shortle    41    DEC PDP-11,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x41)
    }
    if m1 {
      out = append(out, "DEC PDP-11,")
    }

    // >0x12    shortle    42    FX66,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x42)
    }
    if m1 {
      out = append(out, "FX66,")
    }

    // >0x12    shortle    43    ST9+ 8/16 bit,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x43)
    }
    if m1 {
      out = append(out, "ST9+ 8/16 bit,")
    }

    // >0x12    shortle    44    ST7 8 bit,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x44)
    }
    if m1 {
      out = append(out, "ST7 8 bit,")
    }

    // >0x12    shortle    45    MC68HC16,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x45)
    }
    if m1 {
      out = append(out, "MC68HC16,")
    }

    // >0x12    shortle    46    MC68HC11,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x46)
    }
    if m1 {
      out = append(out, "MC68HC11,")
    }

    // >0x12    shortle    47    MC68HC08,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x47)
    }
    if m1 {
      out = append(out, "MC68HC08,")
    }

    // >0x12    shortle    48    MC68HC05,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x48)
    }
    if m1 {
      out = append(out, "MC68HC05,")
    }

    // >0x12    shortle    49    SGI SVx or Cray NV1,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x49)
    }
    if m1 {
      out = append(out, "SGI SVx or Cray NV1,")
    }

    // >0x12    shortle    4a    ST19 8 bit,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x4a)
    }
    if m1 {
      out = append(out, "ST19 8 bit,")
    }

    // >0x12    shortle    4b    Digital VAX,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x4b)
    }
    if m1 {
      out = append(out, "Digital VAX,")
    }

    // >0x12    shortle    4c    Axis cris,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x4c)
    }
    if m1 {
      out = append(out, "Axis cris,")
    }

    // >0x12    shortle    4d    Infineon 32-bit embedded,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x4d)
    }
    if m1 {
      out = append(out, "Infineon 32-bit embedded,")
    }

    // >0x12    shortle    4e    Element 14 64-bit DSP,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x4e)
    }
    if m1 {
      out = append(out, "Element 14 64-bit DSP,")
    }

    // >0x12    shortle    4f    LSI Logic 16-bit DSP,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x4f)
    }
    if m1 {
      out = append(out, "LSI Logic 16-bit DSP,")
    }

    // >0x12    shortle    50    MMIX,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x50)
    }
    if m1 {
      out = append(out, "MMIX,")
    }

    // >0x12    shortle    51    Harvard machine-independent,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x51)
    }
    if m1 {
      out = append(out, "Harvard machine-independent,")
    }

    // >0x12    shortle    52    SiTera Prism,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x52)
    }
    if m1 {
      out = append(out, "SiTera Prism,")
    }

    // >0x12    shortle    53    Atmel AVR 8-bit,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x53)
    }
    if m1 {
      out = append(out, "Atmel AVR 8-bit,")
    }

    // >0x12    shortle    54    Fujitsu FR30,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x54)
    }
    if m1 {
      out = append(out, "Fujitsu FR30,")
    }

    // >0x12    shortle    55    Mitsubishi D10V,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x55)
    }
    if m1 {
      out = append(out, "Mitsubishi D10V,")
    }

    // >0x12    shortle    56    Mitsubishi D30V,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x56)
    }
    if m1 {
      out = append(out, "Mitsubishi D30V,")
    }

    // >0x12    shortle    57    NEC v850,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x57)
    }
    if m1 {
      out = append(out, "NEC v850,")
    }

    // >0x12    shortle    58    Renesas M32R,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x58)
    }
    if m1 {
      out = append(out, "Renesas M32R,")
    }

    // >0x12    shortle    59    Matsushita MN10300,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x59)
    }
    if m1 {
      out = append(out, "Matsushita MN10300,")
    }

    // >0x12    shortle    5a    Matsushita MN10200,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x5a)
    }
    if m1 {
      out = append(out, "Matsushita MN10200,")
    }

    // >0x12    shortle    5b    picoJava,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x5b)
    }
    if m1 {
      out = append(out, "picoJava,")
    }

    // >0x12    shortle    5c    OpenRISC,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x5c)
    }
    if m1 {
      out = append(out, "OpenRISC,")
    }

    // >0x12    shortle    5d    ARC Cores Tangent-A5,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x5d)
    }
    if m1 {
      out = append(out, "ARC Cores Tangent-A5,")
    }

    // >0x12    shortle    5e    Tensilica Xtensa,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x5e)
    }
    if m1 {
      out = append(out, "Tensilica Xtensa,")
    }

    // >0x12    shortle    5f    Alphamosaic VideoCore,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x5f)
    }
    if m1 {
      out = append(out, "Alphamosaic VideoCore,")
    }

    // >0x12    shortle    60    Thompson Multimedia,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x60)
    }
    if m1 {
      out = append(out, "Thompson Multimedia,")
    }

    // >0x12    shortle    61    NatSemi 32k,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x61)
    }
    if m1 {
      out = append(out, "NatSemi 32k,")
    }

    // >0x12    shortle    62    Tenor Network TPC,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x62)
    }
    if m1 {
      out = append(out, "Tenor Network TPC,")
    }

    // >0x12    shortle    63    Trebia SNP 1000,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x63)
    }
    if m1 {
      out = append(out, "Trebia SNP 1000,")
    }

    // >0x12    shortle    64    STMicroelectronics ST200,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x64)
    }
    if m1 {
      out = append(out, "STMicroelectronics ST200,")
    }

    // >0x12    shortle    65    Ubicom IP2022,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x65)
    }
    if m1 {
      out = append(out, "Ubicom IP2022,")
    }

    // >0x12    shortle    66    MAX Processor,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x66)
    }
    if m1 {
      out = append(out, "MAX Processor,")
    }

    // >0x12    shortle    67    NatSemi CompactRISC,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x67)
    }
    if m1 {
      out = append(out, "NatSemi CompactRISC,")
    }

    // >0x12    shortle    68    Fujitsu F2MC16,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x68)
    }
    if m1 {
      out = append(out, "Fujitsu F2MC16,")
    }

    // >0x12    shortle    69    TI msp430,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x69)
    }
    if m1 {
      out = append(out, "TI msp430,")
    }

    // >0x12    shortle    6a    Analog Devices Blackfin,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x6a)
    }
    if m1 {
      out = append(out, "Analog Devices Blackfin,")
    }

    // >0x12    shortle    6b    S1C33 Family of Seiko Epson,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x6b)
    }
    if m1 {
      out = append(out, "S1C33 Family of Seiko Epson,")
    }

    // >0x12    shortle    6c    Sharp embedded,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x6c)
    }
    if m1 {
      out = append(out, "Sharp embedded,")
    }

    // >0x12    shortle    6d    Arca RISC,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x6d)
    }
    if m1 {
      out = append(out, "Arca RISC,")
    }

    // >0x12    shortle    6e    PKU-Unity Ltd.,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x6e)
    }
    if m1 {
      out = append(out, "PKU-Unity Ltd.,")
    }

    // >0x12    shortle    6f    eXcess: 16/32/64-bit,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x6f)
    }
    if m1 {
      out = append(out, "eXcess: 16/32/64-bit,")
    }

    // >0x12    shortle    70    Icera Deep Execution Processor,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x70)
    }
    if m1 {
      out = append(out, "Icera Deep Execution Processor,")
    }

    // >0x12    shortle    71    Altera Nios II,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x71)
    }
    if m1 {
      out = append(out, "Altera Nios II,")
    }

    // >0x12    shortle    72    NatSemi CRX,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x72)
    }
    if m1 {
      out = append(out, "NatSemi CRX,")
    }

    // >0x12    shortle    73    Motorola XGATE,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x73)
    }
    if m1 {
      out = append(out, "Motorola XGATE,")
    }

    // >0x12    shortle    74    Infineon C16x/XC16x,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x74)
    }
    if m1 {
      out = append(out, "Infineon C16x/XC16x,")
    }

    // >0x12    shortle    75    Renesas M16C series,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x75)
    }
    if m1 {
      out = append(out, "Renesas M16C series,")
    }

    // >0x12    shortle    76    Microchip dsPIC30F,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x76)
    }
    if m1 {
      out = append(out, "Microchip dsPIC30F,")
    }

    // >0x12    shortle    77    Freescale RISC core,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x77)
    }
    if m1 {
      out = append(out, "Freescale RISC core,")
    }

    // >0x12    shortle    78    Renesas M32C series,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x78)
    }
    if m1 {
      out = append(out, "Renesas M32C series,")
    }

    // >0x12    shortle    83    Altium TSK3000 core,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x83)
    }
    if m1 {
      out = append(out, "Altium TSK3000 core,")
    }

    // >0x12    shortle    84    Freescale RS08,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x84)
    }
    if m1 {
      out = append(out, "Freescale RS08,")
    }

    // >0x12    shortle    86    Cyan Technology eCOG2,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x86)
    }
    if m1 {
      out = append(out, "Cyan Technology eCOG2,")
    }

    // >0x12    shortle    87    Sunplus S+core7 RISC,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x87)
    }
    if m1 {
      out = append(out, "Sunplus S+core7 RISC,")
    }

    // >0x12    shortle    88    New Japan Radio (NJR) 24-bit DSP,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x88)
    }
    if m1 {
      out = append(out, "New Japan Radio (NJR) 24-bit DSP,")
    }

    // >0x12    shortle    89    Broadcom VideoCore III,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x89)
    }
    if m1 {
      out = append(out, "Broadcom VideoCore III,")
    }

    // >0x12    shortle    8a    LatticeMico32,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x8a)
    }
    if m1 {
      out = append(out, "LatticeMico32,")
    }

    // >0x12    shortle    8b    Seiko Epson C17 family,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x8b)
    }
    if m1 {
      out = append(out, "Seiko Epson C17 family,")
    }

    // >0x12    shortle    8c    TI TMS320C6000 DSP family,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x8c)
    }
    if m1 {
      out = append(out, "TI TMS320C6000 DSP family,")
    }

    // >0x12    shortle    8d    TI TMS320C2000 DSP family,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x8d)
    }
    if m1 {
      out = append(out, "TI TMS320C2000 DSP family,")
    }

    // >0x12    shortle    8e    TI TMS320C55x DSP family,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x8e)
    }
    if m1 {
      out = append(out, "TI TMS320C55x DSP family,")
    }

    // >0x12    shortle    a0    STMicroelectronics 64bit VLIW DSP,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xa0)
    }
    if m1 {
      out = append(out, "STMicroelectronics 64bit VLIW DSP,")
    }

    // >0x12    shortle    a1    Cypress M8C,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xa1)
    }
    if m1 {
      out = append(out, "Cypress M8C,")
    }

    // >0x12    shortle    a2    Renesas R32C series,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xa2)
    }
    if m1 {
      out = append(out, "Renesas R32C series,")
    }

    // >0x12    shortle    a3    NXP TriMedia family,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xa3)
    }
    if m1 {
      out = append(out, "NXP TriMedia family,")
    }

    // >0x12    shortle    a4    QUALCOMM DSP6,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xa4)
    }
    if m1 {
      out = append(out, "QUALCOMM DSP6,")
    }

    // >0x12    shortle    a5    Intel 8051 and variants,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xa5)
    }
    if m1 {
      out = append(out, "Intel 8051 and variants,")
    }

    // >0x12    shortle    a6    STMicroelectronics STxP7x family,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xa6)
    }
    if m1 {
      out = append(out, "STMicroelectronics STxP7x family,")
    }

    // >0x12    shortle    a7    Andes embedded RISC,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xa7)
    }
    if m1 {
      out = append(out, "Andes embedded RISC,")
    }

    // >0x12    shortle    a8    Cyan eCOG1X family,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xa8)
    }
    if m1 {
      out = append(out, "Cyan eCOG1X family,")
    }

    // >0x12    shortle    a9    Dallas MAXQ30,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xa9)
    }
    if m1 {
      out = append(out, "Dallas MAXQ30,")
    }

    // >0x12    shortle    aa    New Japan Radio (NJR) 16-bit DSP,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xaa)
    }
    if m1 {
      out = append(out, "New Japan Radio (NJR) 16-bit DSP,")
    }

    // >0x12    shortle    ab    M2000 Reconfigurable RISC,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xab)
    }
    if m1 {
      out = append(out, "M2000 Reconfigurable RISC,")
    }

    // >0x12    shortle    ac    Cray NV2 vector architecture,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xac)
    }
    if m1 {
      out = append(out, "Cray NV2 vector architecture,")
    }

    // >0x12    shortle    ad    Renesas RX family,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xad)
    }
    if m1 {
      out = append(out, "Renesas RX family,")
    }

    // >0x12    shortle    ae    META,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xae)
    }
    if m1 {
      out = append(out, "META,")
    }

    // >0x12    shortle    af    MCST Elbrus,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xaf)
    }
    if m1 {
      out = append(out, "MCST Elbrus,")
    }

    // >0x12    shortle    b0    Cyan Technology eCOG16 family,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xb0)
    }
    if m1 {
      out = append(out, "Cyan Technology eCOG16 family,")
    }

    // >0x12    shortle    b1    NatSemi CompactRISC,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xb1)
    }
    if m1 {
      out = append(out, "NatSemi CompactRISC,")
    }

    // >0x12    shortle    b2    Freescale Extended Time Processing Unit,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xb2)
    }
    if m1 {
      out = append(out, "Freescale Extended Time Processing Unit,")
    }

    // >0x12    shortle    b3    Infineon SLE9X,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xb3)
    }
    if m1 {
      out = append(out, "Infineon SLE9X,")
    }

    // >0x12    shortle    b4    Intel L1OM,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xb4)
    }
    if m1 {
      out = append(out, "Intel L1OM,")
    }

    // >0x12    shortle    b5    Intel K1OM,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xb5)
    }
    if m1 {
      out = append(out, "Intel K1OM,")
    }

    // >0x12    shortle    b7    ARM aarch64,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xb7)
    }
    if m1 {
      out = append(out, "ARM aarch64,")
    }

    // >0x12    shortle    b9    Atmel 32-bit family,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xb9)
    }
    if m1 {
      out = append(out, "Atmel 32-bit family,")
    }

    // >0x12    shortle    ba    STMicroeletronics STM8 8-bit,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xba)
    }
    if m1 {
      out = append(out, "STMicroeletronics STM8 8-bit,")
    }

    // >0x12    shortle    bb    Tilera TILE64,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xbb)
    }
    if m1 {
      out = append(out, "Tilera TILE64,")
    }

    // >0x12    shortle    bc    Tilera TILEPro,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xbc)
    }
    if m1 {
      out = append(out, "Tilera TILEPro,")
    }

    // >0x12    shortle    bd    Xilinx MicroBlaze 32-bit RISC,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xbd)
    }
    if m1 {
      out = append(out, "Xilinx MicroBlaze 32-bit RISC,")
    }

    // >0x12    shortle    be    NVIDIA CUDA architecture,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xbe)
    }
    if m1 {
      out = append(out, "NVIDIA CUDA architecture,")
    }

    // >0x12    shortle    bf    Tilera TILE-Gx,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xbf)
    }
    if m1 {
      out = append(out, "Tilera TILE-Gx,")
    }

    // >0x12    shortle    c5    Renesas RL78 family,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xc5)
    }
    if m1 {
      out = append(out, "Renesas RL78 family,")
    }

    // >0x12    shortle    c7    Renesas 78K0R,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xc7)
    }
    if m1 {
      out = append(out, "Renesas 78K0R,")
    }

    // >0x12    shortle    1057    AVR (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x1057)
    }
    if m1 {
      out = append(out, "AVR (unofficial),")
    }

    // >0x12    shortle    1059    MSP430 (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x1059)
    }
    if m1 {
      out = append(out, "MSP430 (unofficial),")
    }

    // >0x12    shortle    1223    Adapteva Epiphany (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x1223)
    }
    if m1 {
      out = append(out, "Adapteva Epiphany (unofficial),")
    }

    // >0x12    shortle    2530    Morpho MT (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x2530)
    }
    if m1 {
      out = append(out, "Morpho MT (unofficial),")
    }

    // >0x12    shortle    3330    FR30 (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x3330)
    }
    if m1 {
      out = append(out, "FR30 (unofficial),")
    }

    // >0x12    shortle    3426    OpenRISC (obsolete),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x3426)
    }
    if m1 {
      out = append(out, "OpenRISC (obsolete),")
    }

    // >0x12    shortle    4688    Infineon C166 (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x4688)
    }
    if m1 {
      out = append(out, "Infineon C166 (unofficial),")
    }

    // >0x12    shortle    5441    Cygnus FRV (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x5441)
    }
    if m1 {
      out = append(out, "Cygnus FRV (unofficial),")
    }

    // >0x12    shortle    5aa5    DLX (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x5aa5)
    }
    if m1 {
      out = append(out, "DLX (unofficial),")
    }

    // >0x12    shortle    7650    Cygnus D10V (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x7650)
    }
    if m1 {
      out = append(out, "Cygnus D10V (unofficial),")
    }

    // >0x12    shortle    7676    Cygnus D30V (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x7676)
    }
    if m1 {
      out = append(out, "Cygnus D30V (unofficial),")
    }

    // >0x12    shortle    8217    Ubicom IP2xxx (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x8217)
    }
    if m1 {
      out = append(out, "Ubicom IP2xxx (unofficial),")
    }

    // >0x12    shortle    8472    OpenRISC (obsolete),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x8472)
    }
    if m1 {
      out = append(out, "OpenRISC (obsolete),")
    }

    // >0x12    shortle    9025    Cygnus PowerPC (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x9025)
    }
    if m1 {
      out = append(out, "Cygnus PowerPC (unofficial),")
    }

    // >0x12    shortle    9026    Alpha (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x9026)
    }
    if m1 {
      out = append(out, "Alpha (unofficial),")
    }

    // >0x12    shortle    9041    Cygnus M32R (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x9041)
    }
    if m1 {
      out = append(out, "Cygnus M32R (unofficial),")
    }

    // >0x12    shortle    9080    Cygnus V850 (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x9080)
    }
    if m1 {
      out = append(out, "Cygnus V850 (unofficial),")
    }

    // >0x12    shortle    a390    IBM S/390 (obsolete),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xa390)
    }
    if m1 {
      out = append(out, "IBM S/390 (obsolete),")
    }

    // >0x12    shortle    abc7    Old Xtensa (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xabc7)
    }
    if m1 {
      out = append(out, "Old Xtensa (unofficial),")
    }

    // >0x12    shortle    ad45    xstormy16 (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xad45)
    }
    if m1 {
      out = append(out, "xstormy16 (unofficial),")
    }

    // >0x12    shortle    baab    Old MicroBlaze (unofficial),,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xbaab)
    }
    if m1 {
      out = append(out, "Old MicroBlaze (unofficial),,")
    }

    // >0x12    shortle    beef    Cygnus MN10300 (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xbeef)
    }
    if m1 {
      out = append(out, "Cygnus MN10300 (unofficial),")
    }

    // >0x12    shortle    dead    Cygnus MN10200 (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xdead)
    }
    if m1 {
      out = append(out, "Cygnus MN10200 (unofficial),")
    }

    // >0x12    shortle    f00d    Toshiba MeP (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xf00d)
    }
    if m1 {
      out = append(out, "Toshiba MeP (unofficial),")
    }

    // >0x12    shortle    feb0    Renesas M32C (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xfeb0)
    }
    if m1 {
      out = append(out, "Renesas M32C (unofficial),")
    }

    // >0x12    shortle    feba    Vitesse IQ2000 (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xfeba)
    }
    if m1 {
      out = append(out, "Vitesse IQ2000 (unofficial),")
    }

    // >0x12    shortle    febb    NIOS (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xfebb)
    }
    if m1 {
      out = append(out, "NIOS (unofficial),")
    }

    // >0x12    shortle    feed    Moxie (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xfeed)
    }
    if m1 {
      out = append(out, "Moxie (unofficial),")
    }

    // >0x12    default    
    off = pageOff + 18
    // uh oh unhandled kind

    if m1 {
      // >>0x12    shortle    0    *unknown arch 0x%x*
      off = pageOff + 18
      {
        iv, ok := readUint16le(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }
      if m2 {
        out = append(out, "*unknown arch 0x%x*")
      }

    }
    // >0x14    longle    0    invalid version
    off = pageOff + 20
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      out = append(out, "invalid version")
    }

    // >0x14    longle    1    version 1
    off = pageOff + 20
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) == 0x1)
    }
    if m1 {
      out = append(out, "version 1")
    }

  }
  return out, nil
}

func IdentifyIcoEntry__Swapped(tb []byte, pageOff int64) ([]string, error) {
  var out []string
  var off int64
  m0 := false
  m1 := false

  if m0 {
    // >0x0    use   cur-ico-entry    
    off = pageOff + 0
    // uh oh unhandled kind

    // >0x4    ushortle    1    \b, %d planes
    off = pageOff + 4
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (int64(int16(iv)) > 0x1)
    }
    if m1 {
      out = append(out, "\\b, %d planes")
    }

    // >0x6    ushortle    1    \b, %d bits/pixel
    off = pageOff + 6
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (int64(int16(iv)) > 0x1)
    }
    if m1 {
      out = append(out, "\\b, %d bits/pixel")
    }

  }
  return out, nil
}

